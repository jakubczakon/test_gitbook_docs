<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>optuna.multi_objective.study API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>optuna.multi_objective.study</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import types
from typing import Any
from typing import Callable
from typing import Dict
from typing import Iterable
from typing import List
from typing import Optional
from typing import Sequence
from typing import Tuple
from typing import Type
from typing import Union

import optuna
from optuna._experimental import experimental
from optuna import logging
from optuna import multi_objective
from optuna.storages import BaseStorage
from optuna.study import Study
from optuna.study import StudyDirection
from optuna.trial import FrozenTrial
from optuna.trial import Trial
from optuna.trial import TrialState

ObjectiveFuncType = Callable[[&#34;multi_objective.trial.MultiObjectiveTrial&#34;], Sequence[float]]
CallbackFuncType = Callable[
    [
        &#34;multi_objective.study.MultiObjectiveStudy&#34;,
        &#34;multi_objective.trial.FrozenMultiObjectiveTrial&#34;,
    ],
    None,
]

_logger = logging.get_logger(__name__)


# TODO(ohta): Reconsider the API design.
# See https://github.com/optuna/optuna/pull/1054/files#r407255282 for the detail.
#
# TODO(ohta): Consider to add `objective_labels` argument.
# See: https://github.com/optuna/optuna/pull/1054#issuecomment-616382152
@experimental(&#34;1.4.0&#34;)
def create_study(
    directions: List[str],
    study_name: Optional[str] = None,
    storage: Optional[Union[str, BaseStorage]] = None,
    sampler: Optional[&#34;multi_objective.samplers.BaseMultiObjectiveSampler&#34;] = None,
    load_if_exists: bool = False,
) -&gt; &#34;multi_objective.study.MultiObjectiveStudy&#34;:
    &#34;&#34;&#34;Create a new :class:`~optuna.multi_objective.study.MultiObjectiveStudy`.

    Example:

        .. testcode::

            import optuna

            def objective(trial):
                # Binh and Korn function.
                x = trial.suggest_float(&#34;x&#34;, 0, 5)
                y = trial.suggest_float(&#34;y&#34;, 0, 3)

                v0 = 4 * x ** 2 + 4 * y ** 2
                v1 = (x - 5) ** 2 + (y - 5) ** 2
                return v0, v1

            study = optuna.multi_objective.create_study([&#34;minimize&#34;, &#34;minimize&#34;])
            study.optimize(objective, n_trials=3)

    Args:
        directions:
            Optimization direction for each objective value.
            Set ``minimize`` for minimization and ``maximize`` for maximization.
        study_name:
            Study&#39;s name. If this argument is set to None, a unique name is generated
            automatically.
        storage:
            Database URL. If this argument is set to None, in-memory storage is used, and the
            :class:`~optuna.study.Study` will not be persistent.

            .. note::
                When a database URL is passed, Optuna internally uses `SQLAlchemy`_ to handle
                the database. Please refer to `SQLAlchemy&#39;s document`_ for further details.
                If you want to specify non-default options to `SQLAlchemy Engine`_, you can
                instantiate :class:`~optuna.storages.RDBStorage` with your desired options and
                pass it to the ``storage`` argument instead of a URL.

             .. _SQLAlchemy: https://www.sqlalchemy.org/
             .. _SQLAlchemy&#39;s document:
                 https://docs.sqlalchemy.org/en/latest/core/engines.html#database-urls
             .. _SQLAlchemy Engine: https://docs.sqlalchemy.org/en/latest/core/engines.html

        sampler:
            A sampler object that implements background algorithm for value suggestion.
            If :obj:`None` is specified,
            :class:`~optuna.multi_objective.samplers.NSGAIIMultiObjectiveSampler` is used
            as the default. See also :class:`~optuna.multi_objective.samplers`.
        load_if_exists:
            Flag to control the behavior to handle a conflict of study names.
            In the case where a study named ``study_name`` already exists in the ``storage``,
            a :class:`~optuna.exceptions.DuplicatedStudyError` is raised if ``load_if_exists`` is
            set to :obj:`False`.
            Otherwise, the creation of the study is skipped, and the existing one is returned.

    Returns:
        A :class:`~optuna.multi_objective.study.MultiObjectiveStudy` object.
    &#34;&#34;&#34;

    # TODO(ohta): Support pruner.
    mo_sampler = sampler or multi_objective.samplers.NSGAIIMultiObjectiveSampler()
    sampler_adapter = multi_objective.samplers._MultiObjectiveSamplerAdapter(mo_sampler)

    if not isinstance(directions, Iterable):
        raise TypeError(&#34;`directions` must be a list or other iterable types.&#34;)

    if not all(d in [&#34;minimize&#34;, &#34;maximize&#34;] for d in directions):
        raise ValueError(&#34;`directions` includes unknown direction names.&#34;)

    study = optuna.create_study(
        study_name=study_name,
        storage=storage,
        sampler=sampler_adapter,
        pruner=optuna.pruners.NopPruner(),
        load_if_exists=load_if_exists,
    )

    study.set_system_attr(&#34;multi_objective:study:directions&#34;, list(directions))

    return MultiObjectiveStudy(study)


@experimental(&#34;1.4.0&#34;)
def load_study(
    study_name: str,
    storage: Union[str, BaseStorage],
    sampler: Optional[&#34;multi_objective.samplers.BaseMultiObjectiveSampler&#34;] = None,
) -&gt; &#34;multi_objective.study.MultiObjectiveStudy&#34;:
    &#34;&#34;&#34;Load the existing :class:`MultiObjectiveStudy` that has the specified name.

    Example:

        .. testsetup::

            import os

            if os.path.exists(&#34;example.db&#34;):
                raise RuntimeError(&#34;&#39;example.db&#39; already exists. Please remove it.&#34;)

        .. testcode::

            import optuna

            def objective(trial):
                # Binh and Korn function.
                x = trial.suggest_float(&#34;x&#34;, 0, 5)
                y = trial.suggest_float(&#34;y&#34;, 0, 3)

                v0 = 4 * x ** 2 + 4 * y ** 2
                v1 = (x - 5) ** 2 + (y - 5) ** 2
                return v0, v1

            study = optuna.multi_objective.create_study(
                directions=[&#34;minimize&#34;, &#34;minimize&#34;],
                study_name=&#34;my_study&#34;,
                storage=&#34;sqlite:///example.db&#34;
            )
            study.optimize(objective, n_trials=3)

            loaded_study = optuna.multi_objective.study.load_study(
                study_name=&#34;my_study&#34;,
                storage=&#34;sqlite:///example.db&#34;
            )
            assert len(loaded_study.trials) == len(study.trials)

        .. testcleanup::

            os.remove(&#34;example.db&#34;)

    Args:
        study_name:
            Study&#39;s name. Each study has a unique name as an identifier.
        storage:
            Database URL such as ``sqlite:///example.db``. Please see also the documentation of
            :func:`~optuna.multi_objective.study.create_study` for further details.
        sampler:
            A sampler object that implements background algorithm for value suggestion.
            If :obj:`None` is specified,
            :class:`~optuna.multi_objective.samplers.RandomMultiObjectiveSampler` is used
            as the default. See also :class:`~optuna.multi_objective.samplers`.

    Returns:
        A :class:`~optuna.multi_objective.study.MultiObjectiveStudy` object.
    &#34;&#34;&#34;

    mo_sampler = sampler or multi_objective.samplers.RandomMultiObjectiveSampler()
    sampler_adapter = multi_objective.samplers._MultiObjectiveSamplerAdapter(mo_sampler)

    study = optuna.load_study(study_name=study_name, storage=storage, sampler=sampler_adapter)

    return MultiObjectiveStudy(study)


@experimental(&#34;1.4.0&#34;)
class MultiObjectiveStudy(object):
    &#34;&#34;&#34;A study corresponds to a multi-objective optimization task, i.e., a set of trials.

    This object provides interfaces to run a new
    :class:`~optuna.multi_objective.trial.Trial`, access trials&#39;
    history, set/get user-defined attributes of the study itself.

    Note that the direct use of this constructor is not recommended.
    To create and load a study, please refer to the documentation of
    :func:`~optuna.multi_objective.study.create_study` and
    :func:`~optuna.multi_objective.study.load_study` respectively.
    &#34;&#34;&#34;

    def __init__(self, study: Study):
        self._study = study

        self._directions = []
        for d in study.system_attrs[&#34;multi_objective:study:directions&#34;]:
            if d == &#34;minimize&#34;:
                self._directions.append(StudyDirection.MINIMIZE)
            elif d == &#34;maximize&#34;:
                self._directions.append(StudyDirection.MAXIMIZE)
            else:
                raise ValueError(&#34;Unknown direction ({}) is specified.&#34;.format(d))

        n_objectives = len(self._directions)
        if n_objectives &lt; 1:
            raise ValueError(&#34;The number of objectives must be greater than 0.&#34;)

        self._study._log_completed_trial = types.MethodType(  # type: ignore
            _log_completed_trial, self._study
        )

    @property
    def n_objectives(self) -&gt; int:
        &#34;&#34;&#34;Return the number of objectives.

        Returns:
            Number of objectives.
        &#34;&#34;&#34;

        return len(self._directions)

    @property
    def directions(self) -&gt; List[StudyDirection]:
        &#34;&#34;&#34;Return the optimization direction list.

        Returns:
            A list that contains the optimization direction for each objective value.
        &#34;&#34;&#34;

        return self._directions

    @property
    def sampler(self) -&gt; &#34;multi_objective.samplers.BaseMultiObjectiveSampler&#34;:
        &#34;&#34;&#34;Return the sampler.

        Returns:
            A :class:`~multi_objective.samplers.BaseMultiObjectiveSampler` object.
        &#34;&#34;&#34;

        adapter = self._study.sampler
        assert isinstance(adapter, multi_objective.samplers._MultiObjectiveSamplerAdapter)

        return adapter._mo_sampler

    def optimize(
        self,
        objective: ObjectiveFuncType,
        timeout: Optional[int] = None,
        n_trials: Optional[int] = None,
        n_jobs: int = 1,
        catch: Tuple[Type[Exception], ...] = (),
        callbacks: Optional[List[CallbackFuncType]] = None,
        gc_after_trial: bool = True,
        show_progress_bar: bool = False,
    ) -&gt; None:
        &#34;&#34;&#34;Optimize an objective function.

        This method is the same as :func:`optuna.study.Study.optimize` except for
        taking an objective function that returns multi-objective values as the argument.

        Please refer to the documentation of :func:`optuna.study.Study.optimize`
        for further details.

        Example:

            .. testcode::

                import optuna

                def objective(trial):
                    # Binh and Korn function.
                    x = trial.suggest_float(&#34;x&#34;, 0, 5)
                    y = trial.suggest_float(&#34;y&#34;, 0, 3)

                    v0 = 4 * x ** 2 + 4 * y ** 2
                    v1 = (x - 5) ** 2 + (y - 5) ** 2
                    return v0, v1

                study = optuna.multi_objective.create_study([&#34;minimize&#34;, &#34;minimize&#34;])
                study.optimize(objective, n_trials=3)
        &#34;&#34;&#34;

        def mo_objective(trial: Trial) -&gt; float:
            mo_trial = multi_objective.trial.MultiObjectiveTrial(trial)
            values = objective(mo_trial)
            mo_trial._report_complete_values(values)
            return 0.0  # Dummy value.

        # Wraps a multi-objective callback so that we can pass it to the `Study.optimize` method.
        def wrap_mo_callback(callback: CallbackFuncType) -&gt; Callable[[Study, FrozenTrial], None]:
            return lambda study, trial: callback(
                MultiObjectiveStudy(study),
                multi_objective.trial.FrozenMultiObjectiveTrial(self.n_objectives, trial),
            )

        if callbacks is None:
            wrapped_callbacks = None
        else:
            wrapped_callbacks = [wrap_mo_callback(callback) for callback in callbacks]

        self._study.optimize(
            mo_objective,
            timeout=timeout,
            n_trials=n_trials,
            n_jobs=n_jobs,
            catch=catch,
            callbacks=wrapped_callbacks,
            gc_after_trial=gc_after_trial,
            show_progress_bar=show_progress_bar,
        )

    @property
    def user_attrs(self) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;Return user attributes.

        Returns:
            A dictionary containing all user attributes.
        &#34;&#34;&#34;

        return self._study.user_attrs

    @property
    def system_attrs(self) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;Return system attributes.

        Returns:
            A dictionary containing all system attributes.
        &#34;&#34;&#34;

        return self._study.system_attrs

    def set_user_attr(self, key: str, value: Any) -&gt; None:
        &#34;&#34;&#34;Set a user attribute to the study.

        Args:
            key: A key string of the attribute.
            value: A value of the attribute. The value should be JSON serializable.
        &#34;&#34;&#34;

        self._study.set_user_attr(key, value)

    def set_system_attr(self, key: str, value: Any) -&gt; None:
        &#34;&#34;&#34;Set a system attribute to the study.

        Note that Optuna internally uses this method to save system messages. Please use
        :func:`~optuna.multi_objective.study.MultiObjectiveStudy.set_user_attr`
        to set users&#39; attributes.

        Args:
            key: A key string of the attribute.
            value: A value of the attribute. The value should be JSON serializable.

        &#34;&#34;&#34;

        self._study.set_system_attr(key, value)

    def enqueue_trial(self, params: Dict[str, Any]) -&gt; None:
        &#34;&#34;&#34;Enqueue a trial with given parameter values.

        You can fix the next sampling parameters which will be evaluated in your
        objective function.

        Please refer to the documentation of :func:`optuna.study.Study.enqueue_trial`
        for further details.

        Args:
            params:
                Parameter values to pass your objective function.
        &#34;&#34;&#34;

        self._study.enqueue_trial(params)

    @property
    def trials(self) -&gt; List[&#34;multi_objective.trial.FrozenMultiObjectiveTrial&#34;]:
        &#34;&#34;&#34;Return all trials in the study.

        The returned trials are ordered by trial number.

        This is a short form of ``self.get_trials(deepcopy=True)``.

        Returns:
            A list of :class:`~optuna.multi_objective.trial.FrozenMultiObjectiveTrial` objects.
        &#34;&#34;&#34;

        return self.get_trials(deepcopy=True)

    def get_trials(
        self, deepcopy: bool = True
    ) -&gt; List[&#34;multi_objective.trial.FrozenMultiObjectiveTrial&#34;]:
        &#34;&#34;&#34;Return all trials in the study.

        The returned trials are ordered by trial number.

        For library users, it&#39;s recommended to use more handy
        :attr:`~optuna.multi_objective.study.MultiObjectiveStudy.trials`
        property to get the trials instead.

        Args:
            deepcopy:
                Flag to control whether to apply ``copy.deepcopy()`` to the trials.
                Note that if you set the flag to :obj:`False`, you shouldn&#39;t mutate
                any fields of the returned trial. Otherwise the internal state of
                the study may corrupt and unexpected behavior may happen.

        Returns:
            A list of :class:`~optuna.multi_objective.trial.FrozenMultiObjectiveTrial` objects.
        &#34;&#34;&#34;

        return [
            multi_objective.trial.FrozenMultiObjectiveTrial(self.n_objectives, t)
            for t in self._study.get_trials(deepcopy=deepcopy)
        ]

    def get_pareto_front_trials(self) -&gt; List[&#34;multi_objective.trial.FrozenMultiObjectiveTrial&#34;]:
        &#34;&#34;&#34;Return trials located at the pareto front in the study.

        A trial is located at the pareto front if there are no trials that dominate the trial.
        It&#39;s called that a trial ``t0`` dominates another trial ``t1`` if
        ``all(v0 &lt;= v1) for v0, v1 in zip(t0.values, t1.values)`` and
        ``any(v0 &lt; v1) for v0, v1 in zip(t0.values, t1.values)`` are held.

        Returns:
            A list of :class:`~optuna.multi_objective.trial.FrozenMultiObjectiveTrial` objects.
        &#34;&#34;&#34;

        pareto_front = []
        trials = [t for t in self.trials if t.state == TrialState.COMPLETE]

        # TODO(ohta): Optimize (use the fast non dominated sort defined in the NSGA-II paper).
        for trial in trials:
            dominated = False
            for other in trials:
                if other._dominates(trial, self.directions):
                    dominated = True
                    break

            if not dominated:
                pareto_front.append(trial)

        return pareto_front

    @property
    def _storage(self) -&gt; BaseStorage:
        return self._study._storage

    @property
    def _study_id(self) -&gt; int:
        return self._study._study_id


def _log_completed_trial(self: Study, trial: Trial, result: float) -&gt; None:
    if not _logger.isEnabledFor(logging.INFO):
        return

    values = multi_objective.trial.MultiObjectiveTrial(trial)._get_values()
    _logger.info(
        &#34;Trial {} finished with values: {} with parameters: {}.&#34;.format(
            trial.number, values, trial.params
        )
    )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="optuna.multi_objective.study.create_study"><code class="name flex">
<span>def <span class="ident">create_study</span></span>(<span>directions: List[str], study_name: Union[str, NoneType] = None, storage: Union[str, optuna.storages._base.BaseStorage, NoneType] = None, sampler: Union[_ForwardRef('multi_objective.samplers.BaseMultiObjectiveSampler'), NoneType] = None, load_if_exists: bool = False) ‑> <a title="optuna.multi_objective.study.MultiObjectiveStudy" href="#optuna.multi_objective.study.MultiObjectiveStudy">MultiObjectiveStudy</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create a new :class:<code>~optuna.multi_objective.study.MultiObjectiveStudy</code>.</p>
<h2 id="example">Example</h2>
<div class="admonition testcode">
<p class="admonition-title">Testcode</p>
<p>import optuna</p>
<p>def objective(trial):
# Binh and Korn function.
x = trial.suggest_float("x", 0, 5)
y = trial.suggest_float("y", 0, 3)</p>
<pre><code>v0 = 4 * x ** 2 + 4 * y ** 2
v1 = (x - 5) ** 2 + (y - 5) ** 2
return v0, v1
</code></pre>
<p>study = optuna.multi_objective.create_study(["minimize", "minimize"])
study.optimize(objective, n_trials=3)</p>
</div>
<h2 id="args">Args</h2>
<p>directions:
Optimization direction for each objective value.
Set <code>minimize</code> for minimization and <code>maximize</code> for maximization.
study_name:
Study's name. If this argument is set to None, a unique name is generated
automatically.
storage:
Database URL. If this argument is set to None, in-memory storage is used, and the
:class:<code>~optuna.study.Study</code> will not be persistent.</p>
<pre><code>!!! note "Note"
       When a database URL is passed, Optuna internally uses &lt;code&gt;SQLAlchemy&lt;/code&gt;_ to handle
       the database. Please refer to `SQLAlchemy's document`_ for further details.
       If you want to specify non-default options to &lt;code&gt;SQLAlchemy Engine&lt;/code&gt;_, you can
       instantiate :class:`~optuna.storages.RDBStorage` with your desired options and
       pass it to the &lt;code&gt;storage&lt;/code&gt; argument instead of a URL.

    .. _SQLAlchemy: &lt;https://www.sqlalchemy.org/&gt;
    .. _SQLAlchemy's document:
        &lt;https://docs.sqlalchemy.org/en/latest/core/engines.html#database-urls&gt;
    .. _SQLAlchemy Engine: &lt;https://docs.sqlalchemy.org/en/latest/core/engines.html&gt;
</code></pre>
<p>sampler:
A sampler object that implements background algorithm for value suggestion.
If :obj:<code>None</code> is specified,
:class:<code>~optuna.multi_objective.samplers.NSGAIIMultiObjectiveSampler</code> is used
as the default. See also :class:<code>~optuna.multi_objective.samplers</code>.
load_if_exists:
Flag to control the behavior to handle a conflict of study names.
In the case where a study named <code>study_name</code> already exists in the <code>storage</code>,
a :class:<code>~optuna.exceptions.DuplicatedStudyError</code> is raised if <code>load_if_exists</code> is
set to :obj:<code>False</code>.
Otherwise, the creation of the study is skipped, and the existing one is returned.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Added in v1.4.0 as an experimental feature. The interface may change in newer versions
without prior notice. See <a href="https://github.com/optuna/optuna/releases/tag/v1.4.0.">https://github.com/optuna/optuna/releases/tag/v1.4.0.</a></p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@experimental(&#34;1.4.0&#34;)
def create_study(
    directions: List[str],
    study_name: Optional[str] = None,
    storage: Optional[Union[str, BaseStorage]] = None,
    sampler: Optional[&#34;multi_objective.samplers.BaseMultiObjectiveSampler&#34;] = None,
    load_if_exists: bool = False,
) -&gt; &#34;multi_objective.study.MultiObjectiveStudy&#34;:
    &#34;&#34;&#34;Create a new :class:`~optuna.multi_objective.study.MultiObjectiveStudy`.

    Example:

        .. testcode::

            import optuna

            def objective(trial):
                # Binh and Korn function.
                x = trial.suggest_float(&#34;x&#34;, 0, 5)
                y = trial.suggest_float(&#34;y&#34;, 0, 3)

                v0 = 4 * x ** 2 + 4 * y ** 2
                v1 = (x - 5) ** 2 + (y - 5) ** 2
                return v0, v1

            study = optuna.multi_objective.create_study([&#34;minimize&#34;, &#34;minimize&#34;])
            study.optimize(objective, n_trials=3)

    Args:
        directions:
            Optimization direction for each objective value.
            Set ``minimize`` for minimization and ``maximize`` for maximization.
        study_name:
            Study&#39;s name. If this argument is set to None, a unique name is generated
            automatically.
        storage:
            Database URL. If this argument is set to None, in-memory storage is used, and the
            :class:`~optuna.study.Study` will not be persistent.

            .. note::
                When a database URL is passed, Optuna internally uses `SQLAlchemy`_ to handle
                the database. Please refer to `SQLAlchemy&#39;s document`_ for further details.
                If you want to specify non-default options to `SQLAlchemy Engine`_, you can
                instantiate :class:`~optuna.storages.RDBStorage` with your desired options and
                pass it to the ``storage`` argument instead of a URL.

             .. _SQLAlchemy: https://www.sqlalchemy.org/
             .. _SQLAlchemy&#39;s document:
                 https://docs.sqlalchemy.org/en/latest/core/engines.html#database-urls
             .. _SQLAlchemy Engine: https://docs.sqlalchemy.org/en/latest/core/engines.html

        sampler:
            A sampler object that implements background algorithm for value suggestion.
            If :obj:`None` is specified,
            :class:`~optuna.multi_objective.samplers.NSGAIIMultiObjectiveSampler` is used
            as the default. See also :class:`~optuna.multi_objective.samplers`.
        load_if_exists:
            Flag to control the behavior to handle a conflict of study names.
            In the case where a study named ``study_name`` already exists in the ``storage``,
            a :class:`~optuna.exceptions.DuplicatedStudyError` is raised if ``load_if_exists`` is
            set to :obj:`False`.
            Otherwise, the creation of the study is skipped, and the existing one is returned.

    Returns:
        A :class:`~optuna.multi_objective.study.MultiObjectiveStudy` object.
    &#34;&#34;&#34;

    # TODO(ohta): Support pruner.
    mo_sampler = sampler or multi_objective.samplers.NSGAIIMultiObjectiveSampler()
    sampler_adapter = multi_objective.samplers._MultiObjectiveSamplerAdapter(mo_sampler)

    if not isinstance(directions, Iterable):
        raise TypeError(&#34;`directions` must be a list or other iterable types.&#34;)

    if not all(d in [&#34;minimize&#34;, &#34;maximize&#34;] for d in directions):
        raise ValueError(&#34;`directions` includes unknown direction names.&#34;)

    study = optuna.create_study(
        study_name=study_name,
        storage=storage,
        sampler=sampler_adapter,
        pruner=optuna.pruners.NopPruner(),
        load_if_exists=load_if_exists,
    )

    study.set_system_attr(&#34;multi_objective:study:directions&#34;, list(directions))

    return MultiObjectiveStudy(study)</code></pre>
</details>
</dd>
<dt id="optuna.multi_objective.study.load_study"><code class="name flex">
<span>def <span class="ident">load_study</span></span>(<span>study_name: str, storage: Union[str, optuna.storages._base.BaseStorage], sampler: Union[_ForwardRef('multi_objective.samplers.BaseMultiObjectiveSampler'), NoneType] = None) ‑> <a title="optuna.multi_objective.study.MultiObjectiveStudy" href="#optuna.multi_objective.study.MultiObjectiveStudy">MultiObjectiveStudy</a></span>
</code></dt>
<dd>
<div class="desc"><p>Load the existing :class:<code><a title="optuna.multi_objective.study.MultiObjectiveStudy" href="#optuna.multi_objective.study.MultiObjectiveStudy">MultiObjectiveStudy</a></code> that has the specified name.</p>
<h2 id="example">Example</h2>
<div class="admonition testsetup">
<p class="admonition-title">Testsetup</p>
<p>import os</p>
<p>if os.path.exists("example.db"):
raise RuntimeError("'example.db' already exists. Please remove it.")</p>
</div>
<div class="admonition testcode">
<p class="admonition-title">Testcode</p>
<p>import optuna</p>
<p>def objective(trial):
# Binh and Korn function.
x = trial.suggest_float("x", 0, 5)
y = trial.suggest_float("y", 0, 3)</p>
<pre><code>v0 = 4 * x ** 2 + 4 * y ** 2
v1 = (x - 5) ** 2 + (y - 5) ** 2
return v0, v1
</code></pre>
<p>study = optuna.multi_objective.create_study(
directions=["minimize", "minimize"],
study_name="my_study",
storage="sqlite:///example.db"
)
study.optimize(objective, n_trials=3)</p>
<p>loaded_study = optuna.multi_objective.study.load_study(
study_name="my_study",
storage="sqlite:///example.db"
)
assert len(loaded_study.trials) == len(study.trials)</p>
</div>
<div class="admonition testcleanup">
<p class="admonition-title">Testcleanup</p>
<p>os.remove("example.db")</p>
</div>
<h2 id="args">Args</h2>
<p>study_name:
Study's name. Each study has a unique name as an identifier.
storage:
Database URL such as <code>sqlite:///example.db</code>. Please see also the documentation of
:func:<code>~optuna.multi_objective.study.create_study</code> for further details.
sampler:
A sampler object that implements background algorithm for value suggestion.
If :obj:<code>None</code> is specified,
:class:<code>~optuna.multi_objective.samplers.RandomMultiObjectiveSampler</code> is used
as the default. See also :class:<code>~optuna.multi_objective.samplers</code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Added in v1.4.0 as an experimental feature. The interface may change in newer versions
without prior notice. See <a href="https://github.com/optuna/optuna/releases/tag/v1.4.0.">https://github.com/optuna/optuna/releases/tag/v1.4.0.</a></p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@experimental(&#34;1.4.0&#34;)
def load_study(
    study_name: str,
    storage: Union[str, BaseStorage],
    sampler: Optional[&#34;multi_objective.samplers.BaseMultiObjectiveSampler&#34;] = None,
) -&gt; &#34;multi_objective.study.MultiObjectiveStudy&#34;:
    &#34;&#34;&#34;Load the existing :class:`MultiObjectiveStudy` that has the specified name.

    Example:

        .. testsetup::

            import os

            if os.path.exists(&#34;example.db&#34;):
                raise RuntimeError(&#34;&#39;example.db&#39; already exists. Please remove it.&#34;)

        .. testcode::

            import optuna

            def objective(trial):
                # Binh and Korn function.
                x = trial.suggest_float(&#34;x&#34;, 0, 5)
                y = trial.suggest_float(&#34;y&#34;, 0, 3)

                v0 = 4 * x ** 2 + 4 * y ** 2
                v1 = (x - 5) ** 2 + (y - 5) ** 2
                return v0, v1

            study = optuna.multi_objective.create_study(
                directions=[&#34;minimize&#34;, &#34;minimize&#34;],
                study_name=&#34;my_study&#34;,
                storage=&#34;sqlite:///example.db&#34;
            )
            study.optimize(objective, n_trials=3)

            loaded_study = optuna.multi_objective.study.load_study(
                study_name=&#34;my_study&#34;,
                storage=&#34;sqlite:///example.db&#34;
            )
            assert len(loaded_study.trials) == len(study.trials)

        .. testcleanup::

            os.remove(&#34;example.db&#34;)

    Args:
        study_name:
            Study&#39;s name. Each study has a unique name as an identifier.
        storage:
            Database URL such as ``sqlite:///example.db``. Please see also the documentation of
            :func:`~optuna.multi_objective.study.create_study` for further details.
        sampler:
            A sampler object that implements background algorithm for value suggestion.
            If :obj:`None` is specified,
            :class:`~optuna.multi_objective.samplers.RandomMultiObjectiveSampler` is used
            as the default. See also :class:`~optuna.multi_objective.samplers`.

    Returns:
        A :class:`~optuna.multi_objective.study.MultiObjectiveStudy` object.
    &#34;&#34;&#34;

    mo_sampler = sampler or multi_objective.samplers.RandomMultiObjectiveSampler()
    sampler_adapter = multi_objective.samplers._MultiObjectiveSamplerAdapter(mo_sampler)

    study = optuna.load_study(study_name=study_name, storage=storage, sampler=sampler_adapter)

    return MultiObjectiveStudy(study)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="optuna.multi_objective.study.MultiObjectiveStudy"><code class="flex name class">
<span>class <span class="ident">MultiObjectiveStudy</span></span>
<span>(</span><span>study: <a title="optuna.study.Study" href="../study.html#optuna.study.Study">Study</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>A study corresponds to a multi-objective optimization task, i.e., a set of trials.</p>
<p>This object provides interfaces to run a new
:class:<code>~optuna.multi_objective.trial.Trial</code>, access trials'
history, set/get user-defined attributes of the study itself.</p>
<p>Note that the direct use of this constructor is not recommended.
To create and load a study, please refer to the documentation of
:func:<code>~optuna.multi_objective.study.create_study</code> and
:func:<code>~optuna.multi_objective.study.load_study</code> respectively.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Added in v1.4.0 as an experimental feature. The interface may change in newer versions
without prior notice. See <a href="https://github.com/optuna/optuna/releases/tag/v1.4.0.">https://github.com/optuna/optuna/releases/tag/v1.4.0.</a></p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MultiObjectiveStudy(object):
    &#34;&#34;&#34;A study corresponds to a multi-objective optimization task, i.e., a set of trials.

    This object provides interfaces to run a new
    :class:`~optuna.multi_objective.trial.Trial`, access trials&#39;
    history, set/get user-defined attributes of the study itself.

    Note that the direct use of this constructor is not recommended.
    To create and load a study, please refer to the documentation of
    :func:`~optuna.multi_objective.study.create_study` and
    :func:`~optuna.multi_objective.study.load_study` respectively.
    &#34;&#34;&#34;

    def __init__(self, study: Study):
        self._study = study

        self._directions = []
        for d in study.system_attrs[&#34;multi_objective:study:directions&#34;]:
            if d == &#34;minimize&#34;:
                self._directions.append(StudyDirection.MINIMIZE)
            elif d == &#34;maximize&#34;:
                self._directions.append(StudyDirection.MAXIMIZE)
            else:
                raise ValueError(&#34;Unknown direction ({}) is specified.&#34;.format(d))

        n_objectives = len(self._directions)
        if n_objectives &lt; 1:
            raise ValueError(&#34;The number of objectives must be greater than 0.&#34;)

        self._study._log_completed_trial = types.MethodType(  # type: ignore
            _log_completed_trial, self._study
        )

    @property
    def n_objectives(self) -&gt; int:
        &#34;&#34;&#34;Return the number of objectives.

        Returns:
            Number of objectives.
        &#34;&#34;&#34;

        return len(self._directions)

    @property
    def directions(self) -&gt; List[StudyDirection]:
        &#34;&#34;&#34;Return the optimization direction list.

        Returns:
            A list that contains the optimization direction for each objective value.
        &#34;&#34;&#34;

        return self._directions

    @property
    def sampler(self) -&gt; &#34;multi_objective.samplers.BaseMultiObjectiveSampler&#34;:
        &#34;&#34;&#34;Return the sampler.

        Returns:
            A :class:`~multi_objective.samplers.BaseMultiObjectiveSampler` object.
        &#34;&#34;&#34;

        adapter = self._study.sampler
        assert isinstance(adapter, multi_objective.samplers._MultiObjectiveSamplerAdapter)

        return adapter._mo_sampler

    def optimize(
        self,
        objective: ObjectiveFuncType,
        timeout: Optional[int] = None,
        n_trials: Optional[int] = None,
        n_jobs: int = 1,
        catch: Tuple[Type[Exception], ...] = (),
        callbacks: Optional[List[CallbackFuncType]] = None,
        gc_after_trial: bool = True,
        show_progress_bar: bool = False,
    ) -&gt; None:
        &#34;&#34;&#34;Optimize an objective function.

        This method is the same as :func:`optuna.study.Study.optimize` except for
        taking an objective function that returns multi-objective values as the argument.

        Please refer to the documentation of :func:`optuna.study.Study.optimize`
        for further details.

        Example:

            .. testcode::

                import optuna

                def objective(trial):
                    # Binh and Korn function.
                    x = trial.suggest_float(&#34;x&#34;, 0, 5)
                    y = trial.suggest_float(&#34;y&#34;, 0, 3)

                    v0 = 4 * x ** 2 + 4 * y ** 2
                    v1 = (x - 5) ** 2 + (y - 5) ** 2
                    return v0, v1

                study = optuna.multi_objective.create_study([&#34;minimize&#34;, &#34;minimize&#34;])
                study.optimize(objective, n_trials=3)
        &#34;&#34;&#34;

        def mo_objective(trial: Trial) -&gt; float:
            mo_trial = multi_objective.trial.MultiObjectiveTrial(trial)
            values = objective(mo_trial)
            mo_trial._report_complete_values(values)
            return 0.0  # Dummy value.

        # Wraps a multi-objective callback so that we can pass it to the `Study.optimize` method.
        def wrap_mo_callback(callback: CallbackFuncType) -&gt; Callable[[Study, FrozenTrial], None]:
            return lambda study, trial: callback(
                MultiObjectiveStudy(study),
                multi_objective.trial.FrozenMultiObjectiveTrial(self.n_objectives, trial),
            )

        if callbacks is None:
            wrapped_callbacks = None
        else:
            wrapped_callbacks = [wrap_mo_callback(callback) for callback in callbacks]

        self._study.optimize(
            mo_objective,
            timeout=timeout,
            n_trials=n_trials,
            n_jobs=n_jobs,
            catch=catch,
            callbacks=wrapped_callbacks,
            gc_after_trial=gc_after_trial,
            show_progress_bar=show_progress_bar,
        )

    @property
    def user_attrs(self) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;Return user attributes.

        Returns:
            A dictionary containing all user attributes.
        &#34;&#34;&#34;

        return self._study.user_attrs

    @property
    def system_attrs(self) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;Return system attributes.

        Returns:
            A dictionary containing all system attributes.
        &#34;&#34;&#34;

        return self._study.system_attrs

    def set_user_attr(self, key: str, value: Any) -&gt; None:
        &#34;&#34;&#34;Set a user attribute to the study.

        Args:
            key: A key string of the attribute.
            value: A value of the attribute. The value should be JSON serializable.
        &#34;&#34;&#34;

        self._study.set_user_attr(key, value)

    def set_system_attr(self, key: str, value: Any) -&gt; None:
        &#34;&#34;&#34;Set a system attribute to the study.

        Note that Optuna internally uses this method to save system messages. Please use
        :func:`~optuna.multi_objective.study.MultiObjectiveStudy.set_user_attr`
        to set users&#39; attributes.

        Args:
            key: A key string of the attribute.
            value: A value of the attribute. The value should be JSON serializable.

        &#34;&#34;&#34;

        self._study.set_system_attr(key, value)

    def enqueue_trial(self, params: Dict[str, Any]) -&gt; None:
        &#34;&#34;&#34;Enqueue a trial with given parameter values.

        You can fix the next sampling parameters which will be evaluated in your
        objective function.

        Please refer to the documentation of :func:`optuna.study.Study.enqueue_trial`
        for further details.

        Args:
            params:
                Parameter values to pass your objective function.
        &#34;&#34;&#34;

        self._study.enqueue_trial(params)

    @property
    def trials(self) -&gt; List[&#34;multi_objective.trial.FrozenMultiObjectiveTrial&#34;]:
        &#34;&#34;&#34;Return all trials in the study.

        The returned trials are ordered by trial number.

        This is a short form of ``self.get_trials(deepcopy=True)``.

        Returns:
            A list of :class:`~optuna.multi_objective.trial.FrozenMultiObjectiveTrial` objects.
        &#34;&#34;&#34;

        return self.get_trials(deepcopy=True)

    def get_trials(
        self, deepcopy: bool = True
    ) -&gt; List[&#34;multi_objective.trial.FrozenMultiObjectiveTrial&#34;]:
        &#34;&#34;&#34;Return all trials in the study.

        The returned trials are ordered by trial number.

        For library users, it&#39;s recommended to use more handy
        :attr:`~optuna.multi_objective.study.MultiObjectiveStudy.trials`
        property to get the trials instead.

        Args:
            deepcopy:
                Flag to control whether to apply ``copy.deepcopy()`` to the trials.
                Note that if you set the flag to :obj:`False`, you shouldn&#39;t mutate
                any fields of the returned trial. Otherwise the internal state of
                the study may corrupt and unexpected behavior may happen.

        Returns:
            A list of :class:`~optuna.multi_objective.trial.FrozenMultiObjectiveTrial` objects.
        &#34;&#34;&#34;

        return [
            multi_objective.trial.FrozenMultiObjectiveTrial(self.n_objectives, t)
            for t in self._study.get_trials(deepcopy=deepcopy)
        ]

    def get_pareto_front_trials(self) -&gt; List[&#34;multi_objective.trial.FrozenMultiObjectiveTrial&#34;]:
        &#34;&#34;&#34;Return trials located at the pareto front in the study.

        A trial is located at the pareto front if there are no trials that dominate the trial.
        It&#39;s called that a trial ``t0`` dominates another trial ``t1`` if
        ``all(v0 &lt;= v1) for v0, v1 in zip(t0.values, t1.values)`` and
        ``any(v0 &lt; v1) for v0, v1 in zip(t0.values, t1.values)`` are held.

        Returns:
            A list of :class:`~optuna.multi_objective.trial.FrozenMultiObjectiveTrial` objects.
        &#34;&#34;&#34;

        pareto_front = []
        trials = [t for t in self.trials if t.state == TrialState.COMPLETE]

        # TODO(ohta): Optimize (use the fast non dominated sort defined in the NSGA-II paper).
        for trial in trials:
            dominated = False
            for other in trials:
                if other._dominates(trial, self.directions):
                    dominated = True
                    break

            if not dominated:
                pareto_front.append(trial)

        return pareto_front

    @property
    def _storage(self) -&gt; BaseStorage:
        return self._study._storage

    @property
    def _study_id(self) -&gt; int:
        return self._study._study_id</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="optuna.multi_objective.study.MultiObjectiveStudy.directions"><code class="name">var <span class="ident">directions</span> : List[optuna._study_direction.StudyDirection]</code></dt>
<dd>
<div class="desc"><p>Return the optimization direction list.</p>
<h2 id="returns">Returns</h2>
<p>A list that contains the optimization direction for each objective value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def directions(self) -&gt; List[StudyDirection]:
    &#34;&#34;&#34;Return the optimization direction list.

    Returns:
        A list that contains the optimization direction for each objective value.
    &#34;&#34;&#34;

    return self._directions</code></pre>
</details>
</dd>
<dt id="optuna.multi_objective.study.MultiObjectiveStudy.n_objectives"><code class="name">var <span class="ident">n_objectives</span> : int</code></dt>
<dd>
<div class="desc"><p>Return the number of objectives.</p>
<h2 id="returns">Returns</h2>
<p>Number of objectives.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def n_objectives(self) -&gt; int:
    &#34;&#34;&#34;Return the number of objectives.

    Returns:
        Number of objectives.
    &#34;&#34;&#34;

    return len(self._directions)</code></pre>
</details>
</dd>
<dt id="optuna.multi_objective.study.MultiObjectiveStudy.sampler"><code class="name">var <span class="ident">sampler</span> : optuna.multi_objective.samplers._base.BaseMultiObjectiveSampler</code></dt>
<dd>
<div class="desc"><p>Return the sampler.</p>
<h2 id="returns">Returns</h2>
<p>A :class:<code>~multi_objective.samplers.BaseMultiObjectiveSampler</code> object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def sampler(self) -&gt; &#34;multi_objective.samplers.BaseMultiObjectiveSampler&#34;:
    &#34;&#34;&#34;Return the sampler.

    Returns:
        A :class:`~multi_objective.samplers.BaseMultiObjectiveSampler` object.
    &#34;&#34;&#34;

    adapter = self._study.sampler
    assert isinstance(adapter, multi_objective.samplers._MultiObjectiveSamplerAdapter)

    return adapter._mo_sampler</code></pre>
</details>
</dd>
<dt id="optuna.multi_objective.study.MultiObjectiveStudy.system_attrs"><code class="name">var <span class="ident">system_attrs</span> : Dict[str, Any]</code></dt>
<dd>
<div class="desc"><p>Return system attributes.</p>
<h2 id="returns">Returns</h2>
<p>A dictionary containing all system attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def system_attrs(self) -&gt; Dict[str, Any]:
    &#34;&#34;&#34;Return system attributes.

    Returns:
        A dictionary containing all system attributes.
    &#34;&#34;&#34;

    return self._study.system_attrs</code></pre>
</details>
</dd>
<dt id="optuna.multi_objective.study.MultiObjectiveStudy.trials"><code class="name">var <span class="ident">trials</span> : List[<a title="optuna.multi_objective.trial.FrozenMultiObjectiveTrial" href="trial.html#optuna.multi_objective.trial.FrozenMultiObjectiveTrial">FrozenMultiObjectiveTrial</a>]</code></dt>
<dd>
<div class="desc"><p>Return all trials in the study.</p>
<p>The returned trials are ordered by trial number.</p>
<p>This is a short form of <code>self.get_trials(deepcopy=True)</code>.</p>
<h2 id="returns">Returns</h2>
<p>A list of :class:<code>~optuna.multi_objective.trial.FrozenMultiObjectiveTrial</code> objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def trials(self) -&gt; List[&#34;multi_objective.trial.FrozenMultiObjectiveTrial&#34;]:
    &#34;&#34;&#34;Return all trials in the study.

    The returned trials are ordered by trial number.

    This is a short form of ``self.get_trials(deepcopy=True)``.

    Returns:
        A list of :class:`~optuna.multi_objective.trial.FrozenMultiObjectiveTrial` objects.
    &#34;&#34;&#34;

    return self.get_trials(deepcopy=True)</code></pre>
</details>
</dd>
<dt id="optuna.multi_objective.study.MultiObjectiveStudy.user_attrs"><code class="name">var <span class="ident">user_attrs</span> : Dict[str, Any]</code></dt>
<dd>
<div class="desc"><p>Return user attributes.</p>
<h2 id="returns">Returns</h2>
<p>A dictionary containing all user attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def user_attrs(self) -&gt; Dict[str, Any]:
    &#34;&#34;&#34;Return user attributes.

    Returns:
        A dictionary containing all user attributes.
    &#34;&#34;&#34;

    return self._study.user_attrs</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="optuna.multi_objective.study.MultiObjectiveStudy.enqueue_trial"><code class="name flex">
<span>def <span class="ident">enqueue_trial</span></span>(<span>self, params: Dict[str, Any]) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Enqueue a trial with given parameter values.</p>
<p>You can fix the next sampling parameters which will be evaluated in your
objective function.</p>
<p>Please refer to the documentation of :func:<code><a title="optuna.study.Study.enqueue_trial" href="../study.html#optuna.study.Study.enqueue_trial">Study.enqueue_trial()</a></code>
for further details.</p>
<h2 id="args">Args</h2>
<p>params:
Parameter values to pass your objective function.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enqueue_trial(self, params: Dict[str, Any]) -&gt; None:
    &#34;&#34;&#34;Enqueue a trial with given parameter values.

    You can fix the next sampling parameters which will be evaluated in your
    objective function.

    Please refer to the documentation of :func:`optuna.study.Study.enqueue_trial`
    for further details.

    Args:
        params:
            Parameter values to pass your objective function.
    &#34;&#34;&#34;

    self._study.enqueue_trial(params)</code></pre>
</details>
</dd>
<dt id="optuna.multi_objective.study.MultiObjectiveStudy.get_pareto_front_trials"><code class="name flex">
<span>def <span class="ident">get_pareto_front_trials</span></span>(<span>self) ‑> List[<a title="optuna.multi_objective.trial.FrozenMultiObjectiveTrial" href="trial.html#optuna.multi_objective.trial.FrozenMultiObjectiveTrial">FrozenMultiObjectiveTrial</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Return trials located at the pareto front in the study.</p>
<p>A trial is located at the pareto front if there are no trials that dominate the trial.
It's called that a trial <code>t0</code> dominates another trial <code>t1</code> if
<code>all(v0 &lt;= v1) for v0, v1 in zip(t0.values, t1.values)</code> and
<code>any(v0 &lt; v1) for v0, v1 in zip(t0.values, t1.values)</code> are held.</p>
<h2 id="returns">Returns</h2>
<p>A list of :class:<code>~optuna.multi_objective.trial.FrozenMultiObjectiveTrial</code> objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pareto_front_trials(self) -&gt; List[&#34;multi_objective.trial.FrozenMultiObjectiveTrial&#34;]:
    &#34;&#34;&#34;Return trials located at the pareto front in the study.

    A trial is located at the pareto front if there are no trials that dominate the trial.
    It&#39;s called that a trial ``t0`` dominates another trial ``t1`` if
    ``all(v0 &lt;= v1) for v0, v1 in zip(t0.values, t1.values)`` and
    ``any(v0 &lt; v1) for v0, v1 in zip(t0.values, t1.values)`` are held.

    Returns:
        A list of :class:`~optuna.multi_objective.trial.FrozenMultiObjectiveTrial` objects.
    &#34;&#34;&#34;

    pareto_front = []
    trials = [t for t in self.trials if t.state == TrialState.COMPLETE]

    # TODO(ohta): Optimize (use the fast non dominated sort defined in the NSGA-II paper).
    for trial in trials:
        dominated = False
        for other in trials:
            if other._dominates(trial, self.directions):
                dominated = True
                break

        if not dominated:
            pareto_front.append(trial)

    return pareto_front</code></pre>
</details>
</dd>
<dt id="optuna.multi_objective.study.MultiObjectiveStudy.get_trials"><code class="name flex">
<span>def <span class="ident">get_trials</span></span>(<span>self, deepcopy: bool = True) ‑> List[<a title="optuna.multi_objective.trial.FrozenMultiObjectiveTrial" href="trial.html#optuna.multi_objective.trial.FrozenMultiObjectiveTrial">FrozenMultiObjectiveTrial</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Return all trials in the study.</p>
<p>The returned trials are ordered by trial number.</p>
<p>For library users, it's recommended to use more handy
:attr:<code>~optuna.multi_objective.study.MultiObjectiveStudy.trials</code>
property to get the trials instead.</p>
<h2 id="args">Args</h2>
<p>deepcopy:
Flag to control whether to apply <code>copy.deepcopy()</code> to the trials.
Note that if you set the flag to :obj:<code>False</code>, you shouldn't mutate
any fields of the returned trial. Otherwise the internal state of
the study may corrupt and unexpected behavior may happen.</p>
<h2 id="returns">Returns</h2>
<p>A list of :class:<code>~optuna.multi_objective.trial.FrozenMultiObjectiveTrial</code> objects.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_trials(
    self, deepcopy: bool = True
) -&gt; List[&#34;multi_objective.trial.FrozenMultiObjectiveTrial&#34;]:
    &#34;&#34;&#34;Return all trials in the study.

    The returned trials are ordered by trial number.

    For library users, it&#39;s recommended to use more handy
    :attr:`~optuna.multi_objective.study.MultiObjectiveStudy.trials`
    property to get the trials instead.

    Args:
        deepcopy:
            Flag to control whether to apply ``copy.deepcopy()`` to the trials.
            Note that if you set the flag to :obj:`False`, you shouldn&#39;t mutate
            any fields of the returned trial. Otherwise the internal state of
            the study may corrupt and unexpected behavior may happen.

    Returns:
        A list of :class:`~optuna.multi_objective.trial.FrozenMultiObjectiveTrial` objects.
    &#34;&#34;&#34;

    return [
        multi_objective.trial.FrozenMultiObjectiveTrial(self.n_objectives, t)
        for t in self._study.get_trials(deepcopy=deepcopy)
    ]</code></pre>
</details>
</dd>
<dt id="optuna.multi_objective.study.MultiObjectiveStudy.optimize"><code class="name flex">
<span>def <span class="ident">optimize</span></span>(<span>self, objective: Callable[[_ForwardRef('multi_objective.trial.MultiObjectiveTrial')], Sequence[float]], timeout: Union[int, NoneType] = None, n_trials: Union[int, NoneType] = None, n_jobs: int = 1, catch: Tuple[Type[Exception], ...] = (), callbacks: Union[List[Callable[[_ForwardRef('multi_objective.study.MultiObjectiveStudy'), _ForwardRef('multi_objective.trial.FrozenMultiObjectiveTrial')], NoneType]], NoneType] = None, gc_after_trial: bool = True, show_progress_bar: bool = False) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Optimize an objective function.</p>
<p>This method is the same as :func:<code><a title="optuna.study.Study.optimize" href="../study.html#optuna.study.Study.optimize">Study.optimize()</a></code> except for
taking an objective function that returns multi-objective values as the argument.</p>
<p>Please refer to the documentation of :func:<code><a title="optuna.study.Study.optimize" href="../study.html#optuna.study.Study.optimize">Study.optimize()</a></code>
for further details.</p>
<h2 id="example">Example</h2>
<div class="admonition testcode">
<p class="admonition-title">Testcode</p>
<p>import optuna</p>
<p>def objective(trial):
# Binh and Korn function.
x = trial.suggest_float("x", 0, 5)
y = trial.suggest_float("y", 0, 3)</p>
<pre><code>v0 = 4 * x ** 2 + 4 * y ** 2
v1 = (x - 5) ** 2 + (y - 5) ** 2
return v0, v1
</code></pre>
<p>study = optuna.multi_objective.create_study(["minimize", "minimize"])
study.optimize(objective, n_trials=3)</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def optimize(
    self,
    objective: ObjectiveFuncType,
    timeout: Optional[int] = None,
    n_trials: Optional[int] = None,
    n_jobs: int = 1,
    catch: Tuple[Type[Exception], ...] = (),
    callbacks: Optional[List[CallbackFuncType]] = None,
    gc_after_trial: bool = True,
    show_progress_bar: bool = False,
) -&gt; None:
    &#34;&#34;&#34;Optimize an objective function.

    This method is the same as :func:`optuna.study.Study.optimize` except for
    taking an objective function that returns multi-objective values as the argument.

    Please refer to the documentation of :func:`optuna.study.Study.optimize`
    for further details.

    Example:

        .. testcode::

            import optuna

            def objective(trial):
                # Binh and Korn function.
                x = trial.suggest_float(&#34;x&#34;, 0, 5)
                y = trial.suggest_float(&#34;y&#34;, 0, 3)

                v0 = 4 * x ** 2 + 4 * y ** 2
                v1 = (x - 5) ** 2 + (y - 5) ** 2
                return v0, v1

            study = optuna.multi_objective.create_study([&#34;minimize&#34;, &#34;minimize&#34;])
            study.optimize(objective, n_trials=3)
    &#34;&#34;&#34;

    def mo_objective(trial: Trial) -&gt; float:
        mo_trial = multi_objective.trial.MultiObjectiveTrial(trial)
        values = objective(mo_trial)
        mo_trial._report_complete_values(values)
        return 0.0  # Dummy value.

    # Wraps a multi-objective callback so that we can pass it to the `Study.optimize` method.
    def wrap_mo_callback(callback: CallbackFuncType) -&gt; Callable[[Study, FrozenTrial], None]:
        return lambda study, trial: callback(
            MultiObjectiveStudy(study),
            multi_objective.trial.FrozenMultiObjectiveTrial(self.n_objectives, trial),
        )

    if callbacks is None:
        wrapped_callbacks = None
    else:
        wrapped_callbacks = [wrap_mo_callback(callback) for callback in callbacks]

    self._study.optimize(
        mo_objective,
        timeout=timeout,
        n_trials=n_trials,
        n_jobs=n_jobs,
        catch=catch,
        callbacks=wrapped_callbacks,
        gc_after_trial=gc_after_trial,
        show_progress_bar=show_progress_bar,
    )</code></pre>
</details>
</dd>
<dt id="optuna.multi_objective.study.MultiObjectiveStudy.set_system_attr"><code class="name flex">
<span>def <span class="ident">set_system_attr</span></span>(<span>self, key: str, value: Any) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Set a system attribute to the study.</p>
<p>Note that Optuna internally uses this method to save system messages. Please use
:func:<code>~optuna.multi_objective.study.MultiObjectiveStudy.set_user_attr</code>
to set users' attributes.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>key</code></strong></dt>
<dd>A key string of the attribute.</dd>
<dt><strong><code>value</code></strong></dt>
<dd>A value of the attribute. The value should be JSON serializable.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_system_attr(self, key: str, value: Any) -&gt; None:
    &#34;&#34;&#34;Set a system attribute to the study.

    Note that Optuna internally uses this method to save system messages. Please use
    :func:`~optuna.multi_objective.study.MultiObjectiveStudy.set_user_attr`
    to set users&#39; attributes.

    Args:
        key: A key string of the attribute.
        value: A value of the attribute. The value should be JSON serializable.

    &#34;&#34;&#34;

    self._study.set_system_attr(key, value)</code></pre>
</details>
</dd>
<dt id="optuna.multi_objective.study.MultiObjectiveStudy.set_user_attr"><code class="name flex">
<span>def <span class="ident">set_user_attr</span></span>(<span>self, key: str, value: Any) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Set a user attribute to the study.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>key</code></strong></dt>
<dd>A key string of the attribute.</dd>
<dt><strong><code>value</code></strong></dt>
<dd>A value of the attribute. The value should be JSON serializable.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_user_attr(self, key: str, value: Any) -&gt; None:
    &#34;&#34;&#34;Set a user attribute to the study.

    Args:
        key: A key string of the attribute.
        value: A value of the attribute. The value should be JSON serializable.
    &#34;&#34;&#34;

    self._study.set_user_attr(key, value)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="optuna.multi_objective" href="index.html">optuna.multi_objective</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="optuna.multi_objective.study.create_study" href="#optuna.multi_objective.study.create_study">create_study</a></code></li>
<li><code><a title="optuna.multi_objective.study.load_study" href="#optuna.multi_objective.study.load_study">load_study</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="optuna.multi_objective.study.MultiObjectiveStudy" href="#optuna.multi_objective.study.MultiObjectiveStudy">MultiObjectiveStudy</a></code></h4>
<ul class="">
<li><code><a title="optuna.multi_objective.study.MultiObjectiveStudy.directions" href="#optuna.multi_objective.study.MultiObjectiveStudy.directions">directions</a></code></li>
<li><code><a title="optuna.multi_objective.study.MultiObjectiveStudy.enqueue_trial" href="#optuna.multi_objective.study.MultiObjectiveStudy.enqueue_trial">enqueue_trial</a></code></li>
<li><code><a title="optuna.multi_objective.study.MultiObjectiveStudy.get_pareto_front_trials" href="#optuna.multi_objective.study.MultiObjectiveStudy.get_pareto_front_trials">get_pareto_front_trials</a></code></li>
<li><code><a title="optuna.multi_objective.study.MultiObjectiveStudy.get_trials" href="#optuna.multi_objective.study.MultiObjectiveStudy.get_trials">get_trials</a></code></li>
<li><code><a title="optuna.multi_objective.study.MultiObjectiveStudy.n_objectives" href="#optuna.multi_objective.study.MultiObjectiveStudy.n_objectives">n_objectives</a></code></li>
<li><code><a title="optuna.multi_objective.study.MultiObjectiveStudy.optimize" href="#optuna.multi_objective.study.MultiObjectiveStudy.optimize">optimize</a></code></li>
<li><code><a title="optuna.multi_objective.study.MultiObjectiveStudy.sampler" href="#optuna.multi_objective.study.MultiObjectiveStudy.sampler">sampler</a></code></li>
<li><code><a title="optuna.multi_objective.study.MultiObjectiveStudy.set_system_attr" href="#optuna.multi_objective.study.MultiObjectiveStudy.set_system_attr">set_system_attr</a></code></li>
<li><code><a title="optuna.multi_objective.study.MultiObjectiveStudy.set_user_attr" href="#optuna.multi_objective.study.MultiObjectiveStudy.set_user_attr">set_user_attr</a></code></li>
<li><code><a title="optuna.multi_objective.study.MultiObjectiveStudy.system_attrs" href="#optuna.multi_objective.study.MultiObjectiveStudy.system_attrs">system_attrs</a></code></li>
<li><code><a title="optuna.multi_objective.study.MultiObjectiveStudy.trials" href="#optuna.multi_objective.study.MultiObjectiveStudy.trials">trials</a></code></li>
<li><code><a title="optuna.multi_objective.study.MultiObjectiveStudy.user_attrs" href="#optuna.multi_objective.study.MultiObjectiveStudy.user_attrs">user_attrs</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>