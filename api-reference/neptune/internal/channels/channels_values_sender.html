<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>neptune.internal.channels.channels_values_sender API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>neptune.internal.channels.channels_values_sender</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#
# Copyright (c) 2019, Neptune Labs Sp. z o.o.
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
import logging
import threading
import time
from collections import namedtuple
from itertools import groupby
from queue import Queue, Empty

from bravado.exception import HTTPUnprocessableEntity

from neptune.exceptions import NeptuneException
from neptune.internal.channels.channels import ChannelIdWithValues, ChannelValue, \
    ChannelType, ChannelNamespace
from neptune.internal.threads.neptune_thread import NeptuneThread

_logger = logging.getLogger(__name__)


class ChannelsValuesSender(object):
    _QUEUED_CHANNEL_VALUE = namedtuple(
        &#34;QueuedChannelValue&#34;,
        [&#39;channel_id&#39;, &#39;channel_name&#39;, &#39;channel_type&#39;, &#39;channel_value&#39;, &#39;channel_namespace&#39;]
    )

    __LOCK = threading.RLock()

    def __init__(self, experiment):
        self._experiment = experiment
        self._values_queue = None
        self._sending_thread = None
        self._user_channel_name_to_id_map = dict()
        self._system_channel_name_to_id_map = dict()

    # pylint:disable=protected-access
    def send(self, channel_name, channel_type, channel_value, channel_namespace=ChannelNamespace.USER):
        # Before taking the lock here, we need to check if the sending thread is not running yet.
        # Otherwise, the sending thread could call send() while being join()-ed, which would result
        # in a deadlock.
        if not self._is_running():
            with self.__LOCK:
                if not self._is_running():
                    self._start()

        if channel_namespace == ChannelNamespace.USER:
            namespaced_channel_map = self._user_channel_name_to_id_map
        else:
            namespaced_channel_map = self._system_channel_name_to_id_map

        if channel_name in namespaced_channel_map:
            channel_id = namespaced_channel_map[channel_name]
        else:
            response = self._experiment._create_channel(channel_name, channel_type, channel_namespace)
            channel_id = response.id
            namespaced_channel_map[channel_name] = channel_id

        self._values_queue.put(self._QUEUED_CHANNEL_VALUE(
            channel_id=channel_id,
            channel_name=channel_name,
            channel_type=channel_type,
            channel_value=channel_value,
            channel_namespace=channel_namespace
        ))

    def join(self):
        with self.__LOCK:
            if self._is_running():
                self._sending_thread.interrupt()
                self._sending_thread.join()
                self._sending_thread = None
                self._values_queue = None

    def _is_running(self):
        return self._values_queue is not None and self._sending_thread is not None and self._sending_thread.is_alive()

    def _start(self):
        self._values_queue = Queue()
        self._sending_thread = ChannelsValuesSendingThread(self._experiment, self._values_queue)
        self._sending_thread.start()


class ChannelsValuesSendingThread(NeptuneThread):
    _SLEEP_TIME = 5
    _MAX_VALUES_BATCH_LENGTH = 100
    _MAX_IMAGE_VALUES_BATCH_SIZE = 10485760  # 10 MB

    def __init__(self, experiment, values_queue):
        super(ChannelsValuesSendingThread, self).__init__(is_daemon=False)
        self._values_queue = values_queue
        self._experiment = experiment
        self._sleep_time = self._SLEEP_TIME
        self._values_batch = []

    def run(self):
        while self.should_continue_running() or not self._values_queue.empty():
            try:
                sleep_start = time.time()
                self._values_batch.append(self._values_queue.get(timeout=max(self._sleep_time, 0)))
                self._values_queue.task_done()
                self._sleep_time -= time.time() - sleep_start
            except Empty:
                self._sleep_time = 0

            image_values_batch_size = sum([len(v.channel_value.y[&#39;image_value&#39;][&#39;data&#39;] or [])
                                           for v in self._values_batch
                                           if v.channel_type == ChannelType.IMAGE.value])
            if self._sleep_time &lt;= 0 \
                    or len(self._values_batch) &gt;= self._MAX_VALUES_BATCH_LENGTH \
                    or image_values_batch_size &gt;= self._MAX_IMAGE_VALUES_BATCH_SIZE:  # pylint:disable=line-too-long
                self._process_batch()

        self._process_batch()

    def _process_batch(self):
        send_start = time.time()
        if self._values_batch:
            try:
                self._send_values(self._values_batch)
                self._values_batch = []
            except (NeptuneException, IOError):
                _logger.exception(&#39;Failed to send channel value.&#39;)
        self._sleep_time = self._SLEEP_TIME - (time.time() - send_start)

    def _send_values(self, queued_channels_values):
        def get_channel_id(value):
            return value.channel_id

        queued_grouped_by_channel = {channel_id: list(values)
                                     for channel_id, values
                                     in groupby(sorted(queued_channels_values, key=get_channel_id),
                                                get_channel_id)}
        channels_with_values = []
        for channel_id in queued_grouped_by_channel:
            channel_values = []
            for queued_value in queued_grouped_by_channel[channel_id]:
                channel_values.append(ChannelValue(ts=queued_value.channel_value.ts,
                                                   x=queued_value.channel_value.x,
                                                   y=queued_value.channel_value.y))
            channels_with_values.append(ChannelIdWithValues(channel_id, channel_values))

        try:
            # pylint:disable=protected-access
            self._experiment._send_channels_values(channels_with_values)
        except HTTPUnprocessableEntity as e:
            message = &#34;Maximum storage limit reached&#34;
            try:
                message = e.response.json()[&#34;message&#34;]
            finally:
                _logger.warning(&#39;Failed to send channel value: %s&#39;, message)
        except (NeptuneException, IOError):
            _logger.exception(&#39;Failed to send channel value.&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="neptune.internal.channels.channels_values_sender.ChannelsValuesSender"><code class="flex name class">
<span>class <span class="ident">ChannelsValuesSender</span></span>
<span>(</span><span>experiment)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ChannelsValuesSender(object):
    _QUEUED_CHANNEL_VALUE = namedtuple(
        &#34;QueuedChannelValue&#34;,
        [&#39;channel_id&#39;, &#39;channel_name&#39;, &#39;channel_type&#39;, &#39;channel_value&#39;, &#39;channel_namespace&#39;]
    )

    __LOCK = threading.RLock()

    def __init__(self, experiment):
        self._experiment = experiment
        self._values_queue = None
        self._sending_thread = None
        self._user_channel_name_to_id_map = dict()
        self._system_channel_name_to_id_map = dict()

    # pylint:disable=protected-access
    def send(self, channel_name, channel_type, channel_value, channel_namespace=ChannelNamespace.USER):
        # Before taking the lock here, we need to check if the sending thread is not running yet.
        # Otherwise, the sending thread could call send() while being join()-ed, which would result
        # in a deadlock.
        if not self._is_running():
            with self.__LOCK:
                if not self._is_running():
                    self._start()

        if channel_namespace == ChannelNamespace.USER:
            namespaced_channel_map = self._user_channel_name_to_id_map
        else:
            namespaced_channel_map = self._system_channel_name_to_id_map

        if channel_name in namespaced_channel_map:
            channel_id = namespaced_channel_map[channel_name]
        else:
            response = self._experiment._create_channel(channel_name, channel_type, channel_namespace)
            channel_id = response.id
            namespaced_channel_map[channel_name] = channel_id

        self._values_queue.put(self._QUEUED_CHANNEL_VALUE(
            channel_id=channel_id,
            channel_name=channel_name,
            channel_type=channel_type,
            channel_value=channel_value,
            channel_namespace=channel_namespace
        ))

    def join(self):
        with self.__LOCK:
            if self._is_running():
                self._sending_thread.interrupt()
                self._sending_thread.join()
                self._sending_thread = None
                self._values_queue = None

    def _is_running(self):
        return self._values_queue is not None and self._sending_thread is not None and self._sending_thread.is_alive()

    def _start(self):
        self._values_queue = Queue()
        self._sending_thread = ChannelsValuesSendingThread(self._experiment, self._values_queue)
        self._sending_thread.start()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="neptune.internal.channels.channels_values_sender.ChannelsValuesSender.join"><code class="name flex">
<span>def <span class="ident">join</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def join(self):
    with self.__LOCK:
        if self._is_running():
            self._sending_thread.interrupt()
            self._sending_thread.join()
            self._sending_thread = None
            self._values_queue = None</code></pre>
</details>
</dd>
<dt id="neptune.internal.channels.channels_values_sender.ChannelsValuesSender.send"><code class="name flex">
<span>def <span class="ident">send</span></span>(<span>self, channel_name, channel_type, channel_value, channel_namespace=ChannelNamespace.USER)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send(self, channel_name, channel_type, channel_value, channel_namespace=ChannelNamespace.USER):
    # Before taking the lock here, we need to check if the sending thread is not running yet.
    # Otherwise, the sending thread could call send() while being join()-ed, which would result
    # in a deadlock.
    if not self._is_running():
        with self.__LOCK:
            if not self._is_running():
                self._start()

    if channel_namespace == ChannelNamespace.USER:
        namespaced_channel_map = self._user_channel_name_to_id_map
    else:
        namespaced_channel_map = self._system_channel_name_to_id_map

    if channel_name in namespaced_channel_map:
        channel_id = namespaced_channel_map[channel_name]
    else:
        response = self._experiment._create_channel(channel_name, channel_type, channel_namespace)
        channel_id = response.id
        namespaced_channel_map[channel_name] = channel_id

    self._values_queue.put(self._QUEUED_CHANNEL_VALUE(
        channel_id=channel_id,
        channel_name=channel_name,
        channel_type=channel_type,
        channel_value=channel_value,
        channel_namespace=channel_namespace
    ))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="neptune.internal.channels.channels_values_sender.ChannelsValuesSendingThread"><code class="flex name class">
<span>class <span class="ident">ChannelsValuesSendingThread</span></span>
<span>(</span><span>experiment, values_queue)</span>
</code></dt>
<dd>
<div class="desc"><p>A class that represents a thread of control.</p>
<p>This class can be safely subclassed in a limited fashion. There are two ways
to specify the activity: by passing a callable object to the constructor, or
by overriding the run() method in a subclass.</p>
<p>This constructor should always be called with keyword arguments. Arguments are:</p>
<p><em>group</em> should be None; reserved for future extension when a ThreadGroup
class is implemented.</p>
<p><em>target</em> is the callable object to be invoked by the run()
method. Defaults to None, meaning nothing is called.</p>
<p><em>name</em> is the thread name. By default, a unique name is constructed of
the form "Thread-N" where N is a small decimal number.</p>
<p><em>args</em> is the argument tuple for the target invocation. Defaults to ().</p>
<p><em>kwargs</em> is a dictionary of keyword arguments for the target
invocation. Defaults to {}.</p>
<p>If a subclass overrides the constructor, it must make sure to invoke
the base class constructor (Thread.<strong>init</strong>()) before doing anything
else to the thread.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ChannelsValuesSendingThread(NeptuneThread):
    _SLEEP_TIME = 5
    _MAX_VALUES_BATCH_LENGTH = 100
    _MAX_IMAGE_VALUES_BATCH_SIZE = 10485760  # 10 MB

    def __init__(self, experiment, values_queue):
        super(ChannelsValuesSendingThread, self).__init__(is_daemon=False)
        self._values_queue = values_queue
        self._experiment = experiment
        self._sleep_time = self._SLEEP_TIME
        self._values_batch = []

    def run(self):
        while self.should_continue_running() or not self._values_queue.empty():
            try:
                sleep_start = time.time()
                self._values_batch.append(self._values_queue.get(timeout=max(self._sleep_time, 0)))
                self._values_queue.task_done()
                self._sleep_time -= time.time() - sleep_start
            except Empty:
                self._sleep_time = 0

            image_values_batch_size = sum([len(v.channel_value.y[&#39;image_value&#39;][&#39;data&#39;] or [])
                                           for v in self._values_batch
                                           if v.channel_type == ChannelType.IMAGE.value])
            if self._sleep_time &lt;= 0 \
                    or len(self._values_batch) &gt;= self._MAX_VALUES_BATCH_LENGTH \
                    or image_values_batch_size &gt;= self._MAX_IMAGE_VALUES_BATCH_SIZE:  # pylint:disable=line-too-long
                self._process_batch()

        self._process_batch()

    def _process_batch(self):
        send_start = time.time()
        if self._values_batch:
            try:
                self._send_values(self._values_batch)
                self._values_batch = []
            except (NeptuneException, IOError):
                _logger.exception(&#39;Failed to send channel value.&#39;)
        self._sleep_time = self._SLEEP_TIME - (time.time() - send_start)

    def _send_values(self, queued_channels_values):
        def get_channel_id(value):
            return value.channel_id

        queued_grouped_by_channel = {channel_id: list(values)
                                     for channel_id, values
                                     in groupby(sorted(queued_channels_values, key=get_channel_id),
                                                get_channel_id)}
        channels_with_values = []
        for channel_id in queued_grouped_by_channel:
            channel_values = []
            for queued_value in queued_grouped_by_channel[channel_id]:
                channel_values.append(ChannelValue(ts=queued_value.channel_value.ts,
                                                   x=queued_value.channel_value.x,
                                                   y=queued_value.channel_value.y))
            channels_with_values.append(ChannelIdWithValues(channel_id, channel_values))

        try:
            # pylint:disable=protected-access
            self._experiment._send_channels_values(channels_with_values)
        except HTTPUnprocessableEntity as e:
            message = &#34;Maximum storage limit reached&#34;
            try:
                message = e.response.json()[&#34;message&#34;]
            finally:
                _logger.warning(&#39;Failed to send channel value: %s&#39;, message)
        except (NeptuneException, IOError):
            _logger.exception(&#39;Failed to send channel value.&#39;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="neptune.internal.threads.neptune_thread.NeptuneThread" href="../threads/neptune_thread.html#neptune.internal.threads.neptune_thread.NeptuneThread">NeptuneThread</a></li>
<li>threading.Thread</li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="neptune.internal.threads.neptune_thread.NeptuneThread" href="../threads/neptune_thread.html#neptune.internal.threads.neptune_thread.NeptuneThread">NeptuneThread</a></b></code>:
<ul class="hlist">
<li><code><a title="neptune.internal.threads.neptune_thread.NeptuneThread.run" href="../threads/neptune_thread.html#neptune.internal.threads.neptune_thread.NeptuneThread.run">run</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="neptune.internal.channels" href="index.html">neptune.internal.channels</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="neptune.internal.channels.channels_values_sender.ChannelsValuesSender" href="#neptune.internal.channels.channels_values_sender.ChannelsValuesSender">ChannelsValuesSender</a></code></h4>
<ul class="">
<li><code><a title="neptune.internal.channels.channels_values_sender.ChannelsValuesSender.join" href="#neptune.internal.channels.channels_values_sender.ChannelsValuesSender.join">join</a></code></li>
<li><code><a title="neptune.internal.channels.channels_values_sender.ChannelsValuesSender.send" href="#neptune.internal.channels.channels_values_sender.ChannelsValuesSender.send">send</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="neptune.internal.channels.channels_values_sender.ChannelsValuesSendingThread" href="#neptune.internal.channels.channels_values_sender.ChannelsValuesSendingThread">ChannelsValuesSendingThread</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>