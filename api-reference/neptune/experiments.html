<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>neptune.experiments API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>neptune.experiments</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#
# Copyright (c) 2019, Neptune Labs Sp. z o.o.
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
import base64
import logging
import os
import re
import time
import traceback

import pandas as pd
import requests
import six
from pandas.errors import EmptyDataError

from neptune.api_exceptions import ExperimentAlreadyFinished, ChannelDoesNotExist, PathInProjectNotFound
from neptune.exceptions import FileNotFound, InvalidChannelValue, NoChannelValue, NotADirectory
from neptune.internal.channels.channels import ChannelValue, ChannelType, ChannelNamespace
from neptune.internal.channels.channels_values_sender import ChannelsValuesSender
from neptune.internal.execution.execution_context import ExecutionContext
from neptune.internal.storage.storage_utils import upload_to_storage, UploadEntry, normalize_file_name
from neptune.internal.utils.image import get_image_content
from neptune.utils import align_channels_on_x, is_float, is_nan_or_inf

_logger = logging.getLogger(__name__)


# pylint: disable=too-many-lines
class Experiment(object):
    &#34;&#34;&#34;A class for managing Neptune experiment.

    Each time User creates new experiment instance of this class is created.
    It lets you manage experiment, :meth:`~neptune.experiments.Experiment.log_metric`,
    :meth:`~neptune.experiments.Experiment.log_text`,
    :meth:`~neptune.experiments.Experiment.log_image`,
    :meth:`~neptune.experiments.Experiment.set_property`,
    and much more.


    Args:
        backend (:obj:`neptune.Backend`): A Backend object
        project (:obj:`neptune.Project`): The project this experiment belongs to
        _id (:obj:`str`): Experiment id
        internal_id (:obj:`str`): internal UUID

    Example:
        Assuming that `project` is an instance of :class:`~neptune.projects.Project`.

        .. code:: python3

            experiment = project.create_experiment()

    Warning:
        User should never create instances of this class manually.
        Always use: :meth:`~neptune.projects.Project.create_experiment`.

    &#34;&#34;&#34;

    IMAGE_SIZE_LIMIT_MB = 15

    def __init__(self, backend, project, _id, internal_id):
        self._backend = backend
        self._project = project
        self._id = _id
        self._internal_id = internal_id
        self._channels_values_sender = ChannelsValuesSender(self)
        self._execution_context = ExecutionContext(backend, self)

    @property
    def id(self):
        &#34;&#34;&#34;Experiment short id

        | Combination of project key and unique experiment number.
        | Format is ``&lt;project_key&gt;-&lt;experiment_number&gt;``, for example: ``MPI-142``.

        Returns:
            :obj:`str` - experiment short id

        Examples:
            Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`.

            .. code:: python3

                exp_id = experiment.id

        &#34;&#34;&#34;
        return self._id

    @property
    def name(self):
        &#34;&#34;&#34;Experiment name

        Returns:
            :obj:`str` experiment name

        Examples:
            Assuming that `project` is an instance of :class:`~neptune.projects.Project`.

            .. code:: python3

                experiment = project.create_experiment(&#39;exp_name&#39;)
                exp_name = experiment.name
        &#34;&#34;&#34;
        return self._backend.get_experiment(self._internal_id).name

    @property
    def state(self):
        &#34;&#34;&#34;Current experiment state

        Possible values: `&#39;running&#39;`, `&#39;succeeded&#39;`, `&#39;failed&#39;`, `&#39;aborted&#39;`.

        Returns:
            :obj:`str` - current experiment state

        Examples:
            Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`.

            .. code:: python3

                state_str = experiment.state
        &#34;&#34;&#34;
        return self._backend.get_experiment(self._internal_id).state

    @property
    def internal_id(self):
        return self._internal_id

    @property
    def limits(self):
        return {
            &#39;channels&#39;: {
                &#39;numeric&#39;: 1000,
                &#39;text&#39;: 100,
                &#39;image&#39;: 100
            }
        }

    def get_system_properties(self):
        &#34;&#34;&#34;Retrieve experiment properties.

        | Experiment properties are for example: `owner`, `created`, `name`, `hostname`.
        | List of experiment properties may change over time.

        Returns:
            :obj:`dict` - dictionary mapping a property name to value.

        Examples:
            Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`.

            .. code:: python3

                sys_properties = experiment.get_system_properties
        &#34;&#34;&#34;
        experiment = self._backend.get_experiment(self._internal_id)
        return {
            &#39;id&#39;: experiment.shortId,
            &#39;name&#39;: experiment.name,
            &#39;created&#39;: experiment.timeOfCreation,
            &#39;finished&#39;: experiment.timeOfCompletion,
            &#39;running_time&#39;: experiment.runningTime,
            &#39;owner&#39;: experiment.owner,
            &#39;storage_size&#39;: experiment.storageSize,
            &#39;channels_size&#39;: experiment.channelsSize,
            &#39;size&#39;: experiment.storageSize + experiment.channelsSize,
            &#39;tags&#39;: experiment.tags,
            &#39;notes&#39;: experiment.description,
            &#39;description&#39;: experiment.description,
            &#39;hostname&#39;: experiment.hostname
        }

    def get_tags(self):
        &#34;&#34;&#34;Get tags associated with experiment.

        Returns:
            :obj:`list` of :obj:`str` with all tags for this experiment.

        Example:
            Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`.

            .. code:: python3

                experiment.get_tags()
        &#34;&#34;&#34;
        return self._backend.get_experiment(self._internal_id).tags

    def append_tag(self, tag, *tags):
        &#34;&#34;&#34;Append tag(s) to the current experiment.

        Alias: :meth:`~neptune.experiments.Experiment.append_tags`.
        Only ``[a-zA-Z0-9]`` and ``-`` (dash) characters are allowed in tags.

        Args:
            tag (single :obj:`str` or multiple :obj:`str` or :obj:`list` of :obj:`str`):
                Tag(s) to add to the current experiment.

                    * If :obj:`str` is passed, singe tag is added.
                    * If multiple - comma separated - :obj:`str` are passed, all of them are added as tags.
                    * If :obj:`list` of :obj:`str` is passed, all elements of the :obj:`list` are added as tags.

        Examples:

            .. code:: python3

                neptune.append_tag(&#39;new-tag&#39;)  # single tag
                neptune.append_tag(&#39;first-tag&#39;, &#39;second-tag&#39;, &#39;third-tag&#39;)  # few str
                neptune.append_tag([&#39;first-tag&#39;, &#39;second-tag&#39;, &#39;third-tag&#39;])  # list of str
        &#34;&#34;&#34;
        if isinstance(tag, list):
            tags_list = tag
        else:
            tags_list = [tag] + list(tags)
        self._backend.update_tags(experiment=self,
                                  tags_to_add=tags_list,
                                  tags_to_delete=[])

    def append_tags(self, tag, *tags):
        &#34;&#34;&#34;Append tag(s) to the current experiment.

        Alias for: :meth:`~neptune.experiments.Experiment.append_tag`
        &#34;&#34;&#34;
        self.append_tag(tag, *tags)

    def remove_tag(self, tag):
        &#34;&#34;&#34;Removes single tag from the experiment.

        Args:
            tag (:obj:`str`): Tag to be removed

        Example:
            Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`.

            .. code:: python3

                # assuming experiment has tags: `[&#39;tag-1&#39;, &#39;tag-2&#39;]`.
                experiment.remove_tag(&#39;tag-1&#39;)

        Note:
            Removing a tag that is not assigned to this experiment is silently ignored.
        &#34;&#34;&#34;
        self._backend.update_tags(experiment=self,
                                  tags_to_add=[],
                                  tags_to_delete=[tag])

    def get_channels(self):
        &#34;&#34;&#34;Alias for :meth:`~neptune.experiments.Experiment.get_logs`
        &#34;&#34;&#34;
        return self.get_logs()

    def get_logs(self):
        &#34;&#34;&#34;Retrieve all log names along with their last values for this experiment.

        Returns:
            :obj:`dict` - A dictionary mapping a log names to the log&#39;s last value.

        Example:
            Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`.

            .. code:: python3

                exp_logs = experiment.get_logs()
        &#34;&#34;&#34;
        experiment = self._backend.get_experiment(self.internal_id)
        channels_last_values_by_name = dict((ch.channelName, ch) for ch in experiment.channelsLastValues)
        channels = dict()
        for ch in experiment.channels:
            last_value = channels_last_values_by_name.get(ch.name, None)
            if last_value is not None:
                ch.x = last_value.x
                ch.y = last_value.y
            elif ch.lastX is not None:
                ch.x = ch.lastX
                ch.y = None
            else:
                ch.x = None
                ch.y = None
            channels[ch.name] = ch
        return channels

    def _get_system_channels(self):
        channels = self._backend.get_system_channels(self)
        return dict((ch.name, ch) for ch in channels)

    def send_metric(self, channel_name, x, y=None, timestamp=None):
        &#34;&#34;&#34;Log metrics (numeric values) in Neptune.

        Alias for :meth:`~neptune.experiments.Experiment.log_metric`
        &#34;&#34;&#34;
        return self.log_metric(channel_name, x, y, timestamp)

    def log_metric(self, log_name, x, y=None, timestamp=None):
        &#34;&#34;&#34;Log metrics (numeric values) in Neptune

        | If a log with provided ``log_name`` does not exist, it is created automatically.
        | If log exists (determined by ``log_name``), then new value is appended to it.

        Args:
            log_name (:obj:`str`): The name of log, i.e. `mse`, `loss`, `accuracy`.
            x (:obj:`double`): Depending, whether ``y`` parameter is passed:

                * ``y`` not passed: The value of the log (data-point).
                * ``y`` passed: Index of log entry being appended. Must be strictly increasing.

            y (:obj:`double`, optional, default is ``None``): The value of the log (data-point).
            timestamp (:obj:`time`, optional, default is ``None``):
                Timestamp to be associated with log entry. Must be Unix time.
                If ``None`` is passed, `time.time() &lt;https://docs.python.org/3.6/library/time.html#time.time&gt;`_
                (Python 3.6 example) is invoked to obtain timestamp.

        Example:
            Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment` and
            &#39;accuracy&#39; log does not exists:

            .. code:: python3

                # Both calls below have the same effect

                # Common invocation, providing log name and value
                experiment.log_metric(&#39;accuracy&#39;, 0.5)
                experiment.log_metric(&#39;accuracy&#39;, 0.65)
                experiment.log_metric(&#39;accuracy&#39;, 0.8)

                # Providing both x and y params
                experiment.log_metric(&#39;accuracy&#39;, 0, 0.5)
                experiment.log_metric(&#39;accuracy&#39;, 1, 0.65)
                experiment.log_metric(&#39;accuracy&#39;, 2, 0.8)

        Note:
            For efficiency, logs are uploaded in batches via a queue.
            Hence, if you log a lot of data, you may experience slight delays in Neptune web application.
        Note:
            Passing either ``x`` or ``y`` coordinate as NaN or +/-inf causes this log entry to be ignored.
            Warning is printed to ``stdout``.
        &#34;&#34;&#34;
        x, y = self._get_valid_x_y(x, y)

        if not is_float(y):
            raise InvalidChannelValue(expected_type=&#39;float&#39;, actual_type=type(y).__name__)

        if is_nan_or_inf(y):
            _logger.warning(
                &#39;Invalid metric value: %s for channel %s. &#39;
                &#39;Metrics with nan or +/-inf values will not be sent to server&#39;,
                y,
                log_name)
        elif x is not None and is_nan_or_inf(x):
            _logger.warning(
                &#39;Invalid metric x-coordinate: %s for channel %s. &#39;
                &#39;Metrics with nan or +/-inf x-coordinates will not be sent to server&#39;,
                x,
                log_name)
        else:
            value = ChannelValue(x, dict(numeric_value=y), timestamp)
            self._channels_values_sender.send(log_name, ChannelType.NUMERIC.value, value)

    def send_text(self, channel_name, x, y=None, timestamp=None):
        &#34;&#34;&#34;Log text data in Neptune.

        Alias for :meth:`~neptune.experiments.Experiment.log_text`
        &#34;&#34;&#34;
        return self.log_text(channel_name, x, y, timestamp)

    def log_text(self, log_name, x, y=None, timestamp=None):
        &#34;&#34;&#34;Log text data in Neptune

        | If a log with provided ``log_name`` does not exist, it is created automatically.
        | If log exists (determined by ``log_name``), then new value is appended to it.

        Args:
            log_name (:obj:`str`): The name of log, i.e. `mse`, `my_text_data`, `timing_info`.
            x (:obj:`double` or :obj:`str`): Depending, whether ``y`` parameter is passed:

                * ``y`` not passed: The value of the log (data-point). Must be ``str``.
                * ``y`` passed: Index of log entry being appended. Must be strictly increasing.

            y (:obj:`str`, optional, default is ``None``): The value of the log (data-point).
            timestamp (:obj:`time`, optional, default is ``None``):
                Timestamp to be associated with log entry. Must be Unix time.
                If ``None`` is passed, `time.time() &lt;https://docs.python.org/3.6/library/time.html#time.time&gt;`_
                (Python 3.6 example) is invoked to obtain timestamp.

        Example:
            Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`:

            .. code:: python3

                # common case, where log name and data are passed
                neptune.log_text(&#39;my_text_data&#39;, str(data_item))

                # log_name, x and timestamp are passed
                neptune.log_text(log_name=&#39;logging_losses_as_text&#39;,
                                 x=str(val_loss),
                                 timestamp=1560430912)

        Note:
            For efficiency, logs are uploaded in batches via a queue.
            Hence, if you log a lot of data, you may experience slight delays in Neptune web application.
        Note:
            Passing ``x`` coordinate as NaN or +/-inf causes this log entry to be ignored.
            Warning is printed to ``stdout``.
        &#34;&#34;&#34;
        x, y = self._get_valid_x_y(x, y)

        if x is not None and is_nan_or_inf(x):
            x = None

        if not isinstance(y, six.string_types):
            raise InvalidChannelValue(expected_type=&#39;str&#39;, actual_type=type(y).__name__)

        if x is not None and is_nan_or_inf(x):
            _logger.warning(
                &#39;Invalid metric x-coordinate: %s for channel %s. &#39;
                &#39;Metrics with nan or +/-inf x-coordinates will not be sent to server&#39;,
                x,
                log_name)
        else:
            value = ChannelValue(x, dict(text_value=y), timestamp)
            self._channels_values_sender.send(log_name, ChannelType.TEXT.value, value)

    def send_image(self, channel_name, x, y=None, name=None, description=None, timestamp=None):
        &#34;&#34;&#34;Log image data in Neptune.

        Alias for :meth:`~neptune.experiments.Experiment.log_image`
        &#34;&#34;&#34;
        return self.log_image(channel_name, x, y, name, description, timestamp)

    def log_image(self, log_name, x, y=None, image_name=None, description=None, timestamp=None):
        &#34;&#34;&#34;Log image data in Neptune

        | If a log with provided ``log_name`` does not exist, it is created automatically.
        | If log exists (determined by ``log_name``), then new value is appended to it.

        Args:
            log_name (:obj:`str`): The name of log, i.e. `bboxes`, `visualisations`, `sample_images`.
            x (:obj:`double`): Depending, whether ``y`` parameter is passed:

                * ``y`` not passed: The value of the log (data-point). See ``y`` parameter.
                * ``y`` passed: Index of log entry being appended. Must be strictly increasing.

            y (multiple types supported, optional, default is ``None``):

                The value of the log (data-point). Can be one of the following types:

                * :obj:`PIL image`
                  `Pillow docs &lt;https://pillow.readthedocs.io/en/latest/reference/Image.html#image-module&gt;`_
                * :obj:`matplotlib.figure.Figure`
                  `Matplotlib 3.1.1 docs &lt;https://matplotlib.org/3.1.1/api/_as_gen/matplotlib.figure.Figure.html&gt;`_
                * :obj:`str` - path to image file
                * 2-dimensional :obj:`numpy.array` - interpreted as grayscale image
                * 3-dimensional :obj:`numpy.array` - behavior depends on last dimension

                    * if last dimension is 1 - interpreted as grayscale image
                    * if last dimension is 3 - interpreted as RGB image
                    * if last dimension is 4 - interpreted as RGBA image

            image_name (:obj:`str`, optional, default is ``None``): Image name
            description (:obj:`str`, optional, default is ``None``): Image description
            timestamp (:obj:`time`, optional, default is ``None``):
                Timestamp to be associated with log entry. Must be Unix time.
                If ``None`` is passed, `time.time() &lt;https://docs.python.org/3.6/library/time.html#time.time&gt;`_
                (Python 3.6 example) is invoked to obtain timestamp.

        Example:
            Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`:

            .. code:: python3

                # path to image file
                experiment.log_image(&#39;bbox_images&#39;, &#39;pictures/image.png&#39;)
                experiment.log_image(&#39;bbox_images&#39;, x=5, &#39;pictures/image.png&#39;)
                experiment.log_image(&#39;bbox_images&#39;, &#39;pictures/image.png&#39;, image_name=&#39;difficult_case&#39;)

                # PIL image
                img = PIL.Image.new(&#39;RGB&#39;, (60, 30), color = &#39;red&#39;)
                experiment.log_image(&#39;fig&#39;, img)

                # 2d numpy array
                array = numpy.random.rand(300, 200)*255
                experiment.log_image(&#39;fig&#39;, array)

                # 3d grayscale array
                array = numpy.random.rand(300, 200, 1)*255
                experiment.log_image(&#39;fig&#39;, array)

                # 3d RGB array
                array = numpy.random.rand(300, 200, 3)*255
                experiment.log_image(&#39;fig&#39;, array)

                # 3d RGBA array
                array = numpy.random.rand(300, 200, 4)*255
                experiment.log_image(&#39;fig&#39;, array)

                # matplotlib figure example 1
                from matplotlib import pyplot
                pyplot.plot([1, 2, 3, 4])
                pyplot.ylabel(&#39;some numbers&#39;)
                experiment.log_image(&#39;plots&#39;, plt.gcf())

                # matplotlib figure example 2
                from matplotlib import pyplot
                import numpy

                numpy.random.seed(19680801)
                data = numpy.random.randn(2, 100)

                figure, axs = pyplot.subplots(2, 2, figsize=(5, 5))
                axs[0, 0].hist(data[0])
                axs[1, 0].scatter(data[0], data[1])
                axs[0, 1].plot(data[0], data[1])
                axs[1, 1].hist2d(data[0], data[1])

                experiment.log_image(&#39;diagrams&#39;, figure)

        Note:
            For efficiency, logs are uploaded in batches via a queue.
            Hence, if you log a lot of data, you may experience slight delays in Neptune web application.
        Note:
            Passing ``x`` coordinate as NaN or +/-inf causes this log entry to be ignored.
            Warning is printed to ``stdout``.
        Warning:
            Only images up to 15MB are supported. Larger files will not be logged to Neptune.
        &#34;&#34;&#34;
        x, y = self._get_valid_x_y(x, y)

        if x is not None and is_nan_or_inf(x):
            x = None

        image_content = get_image_content(y)
        if len(image_content) &gt; self.IMAGE_SIZE_LIMIT_MB * 1024 * 1024:
            _logger.warning(&#39;Your image is larger than %dMB. Neptune supports logging images smaller than %dMB. &#39;
                            &#39;Resize or increase compression of this image&#39;,
                            self.IMAGE_SIZE_LIMIT_MB,
                            self.IMAGE_SIZE_LIMIT_MB)
            image_content = None

        input_image = dict(
            name=image_name,
            description=description
        )
        if image_content:
            input_image[&#39;data&#39;] = base64.b64encode(image_content).decode(&#39;utf-8&#39;)

        if x is not None and is_nan_or_inf(x):
            _logger.warning(
                &#39;Invalid metric x-coordinate: %s for channel %s. &#39;
                &#39;Metrics with nan or +/-inf x-coordinates will not be sent to server&#39;,
                x,
                log_name)
        else:
            value = ChannelValue(x, dict(image_value=input_image), timestamp)
            self._channels_values_sender.send(log_name, ChannelType.IMAGE.value, value)

    def send_artifact(self, artifact, destination=None):
        &#34;&#34;&#34;Save an artifact (file) in experiment storage.

        Alias for :meth:`~neptune.experiments.Experiment.log_artifact`
        &#34;&#34;&#34;
        return self.log_artifact(artifact, destination)

    def log_artifact(self, artifact, destination=None):
        &#34;&#34;&#34;Save an artifact (file) in experiment storage.

        Args:
            artifact (:obj:`str` or :obj:`IO object`):
                A path to the file in local filesystem or IO object. It can be open
                file descriptor or in-memory buffer like `io.StringIO` or `io.BytesIO`.
            destination (:obj:`str`, optional, default is ``None``):
                A destination path.
                If ``None`` is passed, an artifact file name will be used.

        Raises:
            `FileNotFound`: When ``artifact`` file was not found.
            `StorageLimitReached`: When storage limit in the project has been reached.

        Example:
            Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`:

            .. code:: python3

                # simple use
                experiment.log_artifact(&#39;images/wrong_prediction_1.png&#39;)

                # save file in other directory
                experiment.log_artifact(&#39;images/wrong_prediction_1.png&#39;, &#39;validation/images/wrong_prediction_1.png&#39;)

                # save file under different name
                experiment.log_artifact(&#39;images/wrong_prediction_1.png&#39;, &#39;images/my_image_1.png&#39;)
        &#34;&#34;&#34;
        if isinstance(artifact, str):
            if os.path.exists(artifact):
                target_name = os.path.basename(artifact) if destination is None else destination
                upload_entry = UploadEntry(os.path.abspath(artifact), normalize_file_name(target_name))
            else:
                raise FileNotFound(artifact)
        elif hasattr(artifact, &#39;read&#39;):
            if destination is not None:
                upload_entry = UploadEntry(artifact, normalize_file_name(destination))
            else:
                raise ValueError(&#34;destination is required for file streams&#34;)
        else:
            raise ValueError(&#34;artifact is a local path or an IO object&#34;)

        upload_to_storage(upload_entries=[upload_entry],
                          upload_api_fun=self._backend.upload_experiment_output,
                          upload_tar_api_fun=self._backend.extract_experiment_output,
                          experiment=self)

    def delete_artifacts(self, path):
        &#34;&#34;&#34;Removes an artifact(s) (file/directory) from the experiment storage.

        Args:
            path (:obj:`list` or :obj:`str`): Path or list of paths to remove from the experiment&#39;s output

        Raises:
            `FileNotFound`: If a path in experiment artifacts does not exist.

        Examples:
            Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`.

            .. code:: python3

                experiment.delete_artifacts(&#39;forest_results.pkl&#39;)
                experiment.delete_artifacts([&#39;forest_results.pkl&#39;, &#39;directory&#39;])
                experiment.delete_artifacts(&#39;&#39;)
        &#34;&#34;&#34;
        if path is None:
            raise ValueError(&#34;path argument must not be None&#34;)

        paths = path
        if not isinstance(path, list):
            paths = [path]
        for path in paths:
            if path is None:
                raise ValueError(&#34;path argument must not be None&#34;)
            normalized_path = os.path.normpath(path)
            if normalized_path.startswith(&#34;..&#34;):
                raise ValueError(&#34;path to delete must be within project&#39;s directory&#34;)
            if normalized_path == &#34;.&#34; or normalized_path == &#34;/&#34; or not normalized_path:
                raise ValueError(&#34;Cannot delete whole artifacts directory&#34;)
        try:
            for path in paths:
                self._backend.rm_data(experiment=self, path=path)
        except PathInProjectNotFound:
            raise FileNotFound(path)

    def download_artifact(self, path, destination_dir=None):
        &#34;&#34;&#34;Download an artifact (file) from the experiment storage.

        Download a file indicated by ``path`` from the experiment artifacts and save it in ``destination_dir``.

        Args:
            path (:obj:`str`): Path to the file to be downloaded.
            destination_dir (:obj:`str`):
                The directory where the file will be downloaded.
                If ``None`` is passed, the file will be downloaded to the current working directory.

        Raises:
            `NotADirectory`: When ``destination_dir`` is not a directory.
            `FileNotFound`: If a path in experiment artifacts does not exist.

        Examples:
            Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`.

            .. code:: python3

                experiment.download_artifact(&#39;forest_results.pkl&#39;, &#39;/home/user/files/&#39;)
        &#34;&#34;&#34;
        if not destination_dir:
            destination_dir = os.getcwd()

        project_storage_path = &#34;/{exp_id}/output/{file}&#34;.format(exp_id=self.id, file=path)
        destination_path = os.path.join(destination_dir, os.path.basename(path))

        if not os.path.exists(destination_dir):
            os.makedirs(destination_dir)
        elif not os.path.isdir(destination_dir):
            raise NotADirectory(destination_dir)

        try:
            self._backend.download_data(self._project, project_storage_path, destination_path)
        except PathInProjectNotFound:
            raise FileNotFound(path)

    def download_sources(self, path=None, destination_dir=None):
        &#34;&#34;&#34;Download a directory or a single file from experiment&#39;s sources as a ZIP archive.

        Download a subdirectory (or file) ``path`` from the experiment sources and save it in ``destination_dir``
        as a ZIP archive. The name of an archive will be a name of downloaded directory (or file) with &#39;.zip&#39; extension.

        Args:
            path (:obj:`str`):
                Path of a directory or file in experiment sources to be downloaded.
                If ``None`` is passed, all source files will be downloaded.

            destination_dir (:obj:`str`): The directory where the archive will be downloaded.
                If ``None`` is passed, the archive will be downloaded to the current working directory.

        Raises:
            `NotADirectory`: When ``destination_dir`` is not a directory.
            `FileNotFound`: If a path in experiment sources does not exist.

        Examples:
            Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`.

            .. code:: python3

                # Download all experiment sources to current working directory
                experiment.download_sources()

                # Download a single directory
                experiment.download_sources(&#39;src/my-module&#39;)

                # Download all experiment sources to user-defined directory
                experiment.download_sources(destination_dir=&#39;/tmp/sources/&#39;)

                # Download a single directory to user-defined directory
                experiment.download_sources(&#39;src/my-module&#39;, &#39;sources/&#39;)
        &#34;&#34;&#34;
        if not path:
            path = &#34;&#34;
        if not destination_dir:
            destination_dir = os.getcwd()

        if not os.path.exists(destination_dir):
            os.makedirs(destination_dir)
        elif not os.path.isdir(destination_dir):
            raise NotADirectory(destination_dir)

        download_request = self._backend.prepare_source_download_reuqest(self, path)
        self._download_from_request(download_request, destination_dir, path)

    def download_artifacts(self, path=None, destination_dir=None):
        &#34;&#34;&#34;Download a directory or a single file from experiment&#39;s artifacts as a ZIP archive.

        Download a subdirectory (or file) ``path`` from the experiment artifacts and save it in ``destination_dir``
        as a ZIP archive. The name of an archive will be a name of downloaded directory (or file) with &#39;.zip&#39; extension.

        Args:
            path (:obj:`str`):
                Path of a directory or file in experiment artifacts to be downloaded.
                If ``None`` is passed, all artifacts will be downloaded.

            destination_dir (:obj:`str`): The directory where the archive will be downloaded.
                If ``None`` is passed, the archive will be downloaded to the current working directory.

        Raises:
            `NotADirectory`: When ``destination_dir`` is not a directory.
            `FileNotFound`: If a path in experiment artifacts does not exist.

        Examples:
            Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`.

            .. code:: python3

                # Download all experiment artifacts to current working directory
                experiment.download_artifacts()

                # Download a single directory
                experiment.download_artifacts(&#39;data/images&#39;)

                # Download all experiment artifacts to user-defined directory
                experiment.download_artifacts(destination_dir=&#39;/tmp/artifacts/&#39;)

                # Download a single directory to user-defined directory
                experiment.download_artifacts(&#39;data/images&#39;, &#39;artifacts/&#39;)
        &#34;&#34;&#34;
        if not path:
            path = &#34;&#34;
        if not destination_dir:
            destination_dir = os.getcwd()

        if not os.path.exists(destination_dir):
            os.makedirs(destination_dir)
        elif not os.path.isdir(destination_dir):
            raise NotADirectory(destination_dir)

        download_request = self._backend.prepare_output_download_reuqest(self, path)
        self._download_from_request(download_request, destination_dir, path)

    def _download_from_request(self, download_request, destination_dir, path):
        sleep_time = 1
        max_sleep_time = 16
        while not hasattr(download_request, &#34;downloadUrl&#34;):
            time.sleep(sleep_time)
            sleep_time = min(sleep_time * 2, max_sleep_time)
            download_request = self._backend.get_download_request(download_request.id)

        ssl_verify = True
        if os.getenv(&#34;NEPTUNE_ALLOW_SELF_SIGNED_CERTIFICATE&#34;):
            ssl_verify = False

        # We do not use Backend here cause `downloadUrl` can be any url (not only Neptune API endpoint)
        response = requests.get(
            url=download_request.downloadUrl,
            headers={&#34;Accept&#34;: &#34;application/zip&#34;},
            stream=True,
            verify=ssl_verify
        )

        with response:
            filename = None
            if &#39;content-disposition&#39; in response.headers:
                content_disposition = response.headers[&#39;content-disposition&#39;]
                filenames = re.findall(&#34;filename=(.+)&#34;, content_disposition)
                if filenames:
                    filename = filenames[0]

            if not filename:
                filename = os.path.basename(path.rstrip(&#34;/&#34;)) + &#34;.zip&#34;

            destination_path = os.path.join(destination_dir, filename)
            with open(destination_path, &#34;wb&#34;) as f:
                for chunk in response.iter_content(chunk_size=10 * 1024 * 1024):
                    if chunk:
                        f.write(chunk)

    def reset_log(self, log_name):
        &#34;&#34;&#34;Resets the log.

        Removes all data from the log and enables it to be reused from scratch.

        Args:
            log_name (:obj:`str`): The name of log to reset.

        Raises:
            `ChannelDoesNotExist`: When the log with name ``log_name`` does not exist on the server.

        Example:
            Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`.

            .. code:: python3

                experiment.reset_log(&#39;my_metric&#39;)

        Note:
            Check Neptune web application to see that reset charts have no data.
        &#34;&#34;&#34;
        channel = self._find_channel(log_name, ChannelNamespace.USER)
        if channel is None:
            raise ChannelDoesNotExist(self.id, log_name)
        self._backend.reset_channel(channel.id)

    def get_parameters(self):
        &#34;&#34;&#34;Retrieve parameters for this experiment.

        Returns:
            :obj:`dict` - dictionary mapping a parameter name to value.

        Examples:
            Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`.

            .. code:: python3

                exp_params = experiment.get_parameters()
        &#34;&#34;&#34;
        experiment = self._backend.get_experiment(self.internal_id)
        return dict((p.name, self._convert_parameter_value(p.value, p.parameterType)) for p in experiment.parameters)

    def get_properties(self):
        &#34;&#34;&#34;Retrieve User-defined properties for this experiment.

        Returns:
            :obj:`dict` - dictionary mapping a property key to value.

        Examples:
            Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`.

            .. code:: python3

                exp_properties = experiment.get_properties()
        &#34;&#34;&#34;
        experiment = self._backend.get_experiment(self.internal_id)
        return dict((p.key, p.value) for p in experiment.properties)

    def set_property(self, key, value):
        &#34;&#34;&#34;Set `key-value` pair as an experiment property.

        If property with given ``key`` does not exist, it adds a new one.

        Args:
            key (:obj:`str`): Property key.
            value (:obj:`obj`): New value of a property.

        Examples:
            Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`:

            .. code:: python3

                experiment.set_property(&#39;model&#39;, &#39;LightGBM&#39;)
                experiment.set_property(&#39;magic-number&#39;, 7)
        &#34;&#34;&#34;
        properties = {p.key: p.value for p in self._backend.get_experiment(self.internal_id).properties}
        properties[key] = str(value)
        return self._backend.update_experiment(
            experiment=self,
            properties=properties
        )

    def remove_property(self, key):
        &#34;&#34;&#34;Removes a property with given key.

        Args:
            key (single :obj:`str`):
                Key of property to remove.

        Examples:
            Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`:

            .. code:: python3

                experiment.remove_property(&#39;host&#39;)
        &#34;&#34;&#34;
        properties = {p.key: p.value for p in self._backend.get_experiment(self.internal_id).properties}
        del properties[key]
        return self._backend.update_experiment(
            experiment=self,
            properties=properties
        )

    def get_hardware_utilization(self):
        &#34;&#34;&#34;Retrieve GPU, CPU and memory utilization data.

        Get hardware utilization metrics for entire experiment as a single
        `pandas.DataFrame &lt;https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html&gt;`_
        object. Returned DataFrame has following columns (assuming single GPU with 0 index):

            * `x_ram` - time (in milliseconds) from the experiment start,
            * `y_ram` - memory usage in GB,
            * `x_cpu` - time (in milliseconds) from the experiment start,
            * `y_cpu` - CPU utilization percentage (0-100),
            * `x_gpu_util_0` - time (in milliseconds) from the experiment start,
            * `y_gpu_util_0` - GPU utilization percentage (0-100),
            * `x_gpu_mem_0` - time (in milliseconds) from the experiment start,
            * `y_gpu_mem_0` - GPU memory usage in GB.

        | If more GPUs are available they have their separate columns with appropriate indices (0, 1, 2, ...),
          for example: `x_gpu_util_1`, `y_gpu_util_1`.
        | The returned DataFrame may contain ``NaN`` s if one of the metrics has more values than others.

        Returns:
            :obj:`pandas.DataFrame` - DataFrame containing the hardware utilization metrics.

        Examples:
            The following values denote that after 3 seconds, the experiment used 16.7 GB of RAM

                * `x_ram` = 3000
                * `y_ram` = 16.7

            Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`:

            .. code:: python3

                hardware_df = experiment.get_hardware_utilization()
        &#34;&#34;&#34;
        metrics_csv = self._backend.get_metrics_csv(self)
        try:
            return pd.read_csv(metrics_csv)
        except EmptyDataError:
            return pd.DataFrame()

    def get_numeric_channels_values(self, *channel_names):
        &#34;&#34;&#34;Retrieve values of specified metrics (numeric logs).

        The returned
        `pandas.DataFrame &lt;https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html&gt;`_
        contains 1 additional column `x` along with the requested metrics.

        Args:
            *channel_names (one or more :obj:`str`): comma-separated metric names.

        Returns:
            :obj:`pandas.DataFrame` - DataFrame containing values for the requested metrics.

            | The returned DataFrame may contain ``NaN`` s if one of the metrics has more values than others.

        Example:
            Invoking ``get_numeric_channels_values(&#39;loss&#39;, &#39;auc&#39;)`` returns DataFrame with columns
            `x`, `loss`, `auc`.

            Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`:

            .. code:: python3

                batch_channels = experiment.get_numeric_channels_values(&#39;batch-1-loss&#39;, &#39;batch-2-metric&#39;)
                epoch_channels = experiment.get_numeric_channels_values(&#39;epoch-1-loss&#39;, &#39;epoch-2-metric&#39;)

        Note:
            It&#39;s good idea to get metrics with common temporal pattern (like iteration or batch/epoch number).
            Thanks to this each row of returned DataFrame has metrics from the same moment in experiment.
            For example, combine epoch metrics to one DataFrame and batch metrics to the other.
        &#34;&#34;&#34;

        channels_data = {}
        channels_by_name = self.get_channels()
        for channel_name in channel_names:
            channel_id = channels_by_name[channel_name].id
            try:
                channels_data[channel_name] = pd.read_csv(
                    self._backend.get_channel_points_csv(self, channel_id),
                    header=None,
                    names=[&#39;x_{}&#39;.format(channel_name), &#39;y_{}&#39;.format(channel_name)],
                    dtype=float
                )
            except EmptyDataError:
                channels_data[channel_name] = pd.DataFrame(
                    columns=[&#39;x_{}&#39;.format(channel_name), &#39;y_{}&#39;.format(channel_name)],
                    dtype=float
                )

        return align_channels_on_x(pd.concat(channels_data.values(), axis=1, sort=False))

    def _start(self,
               upload_source_entries=None,
               abort_callback=None,
               logger=None,
               upload_stdout=True,
               upload_stderr=True,
               send_hardware_metrics=True,
               run_monitoring_thread=True,
               handle_uncaught_exceptions=True):
        upload_to_storage(upload_entries=upload_source_entries,
                          upload_api_fun=self._backend.upload_experiment_source,
                          upload_tar_api_fun=self._backend.extract_experiment_source,
                          warn_limit=100 * 1024 * 1024,
                          experiment=self)

        self._execution_context.start(
            abort_callback=abort_callback,
            logger=logger,
            upload_stdout=upload_stdout,
            upload_stderr=upload_stderr,
            send_hardware_metrics=send_hardware_metrics,
            run_monitoring_thread=run_monitoring_thread,
            handle_uncaught_exceptions=handle_uncaught_exceptions
        )

    def stop(self, exc_tb=None):
        &#34;&#34;&#34;Marks experiment as finished (succeeded or failed).

        Args:
            exc_tb (:obj:`str`, optional, default is ``None``): Additional traceback information
                to be stored in experiment details in case of failure (stacktrace, etc).
                If this argument is ``None`` the experiment will be marked as succeeded.
                Otherwise, experiment will be marked as failed.

        Examples:
            Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`:

            .. code:: python3

                # Marks experiment as succeeded
                experiment.stop()

                # Assuming &#39;ex&#39; is some exception,
                # it marks experiment as failed with exception info in experiment details.
                experiment.stop(str(ex))
        &#34;&#34;&#34;

        self._channels_values_sender.join()

        try:
            if exc_tb is None:
                self._backend.mark_succeeded(self)
            else:
                self._backend.mark_failed(self, exc_tb)
        except ExperimentAlreadyFinished:
            pass

        self._execution_context.stop()

        # pylint: disable=protected-access
        self._project._remove_stopped_experiment(self)

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        if exc_tb is None:
            self.stop()
        else:
            self.stop(&#34;\n&#34;.join(traceback.format_tb(exc_tb)) + &#34;\n&#34; + repr(exc_val))

    def __str__(self):
        return &#39;Experiment({})&#39;.format(self.id)

    def __repr__(self):
        return str(self)

    def __eq__(self, o):
        # pylint: disable=protected-access
        return self._id == o._id and self._internal_id == o._internal_id and self._project == o._project

    def __ne__(self, o):
        return not self.__eq__(o)

    @staticmethod
    def _convert_parameter_value(value, parameter_type):
        if parameter_type == &#39;double&#39;:
            return float(value)
        else:
            return value

    @staticmethod
    def _get_valid_x_y(x, y):
        &#34;&#34;&#34;
        The goal of this function is to allow user to call experiment.log_* with any of:
            - single parameter treated as y value
            - both parameters (named/unnamed)
            - single named y parameter
        If intended X-coordinate is provided, it is validated to be a float value
        &#34;&#34;&#34;
        if x is None and y is None:
            raise NoChannelValue()

        if x is None and y is not None:
            return None, y

        if x is not None and y is None:
            return None, x

        if x is not None and y is not None:
            if not is_float(x):
                raise InvalidChannelValue(expected_type=&#39;float&#39;, actual_type=type(x).__name__)
            return x, y

    def _send_channels_values(self, channels_with_values):
        self._backend.send_channels_values(self, channels_with_values)

    def _get_channels(self, channels_names_with_types):
        existing_channels = self.get_channels()
        channels_by_name = {}
        for (channel_name, channel_type) in channels_names_with_types:
            channel = existing_channels.get(channel_name, None)
            if channel is None:
                channel = self._create_channel(channel_name, channel_type)
            channels_by_name[channel.name] = channel
        return channels_by_name

    def _get_channel(self, channel_name, channel_type, channel_namespace=ChannelNamespace.USER):
        channel = self._find_channel(channel_name, channel_namespace)
        if channel is None:
            channel = self._create_channel(channel_name, channel_type, channel_namespace)
        return channel

    def _find_channel(self, channel_name, channel_namespace):
        if channel_namespace == ChannelNamespace.USER:
            return self.get_channels().get(channel_name, None)
        elif channel_namespace == ChannelNamespace.SYSTEM:
            return self._get_system_channels().get(channel_name, None)
        else:
            raise RuntimeError(&#34;Unknown channel namespace {}&#34;.format(channel_namespace))

    def _create_channel(self, channel_name, channel_type, channel_namespace=ChannelNamespace.USER):
        if channel_namespace == ChannelNamespace.USER:
            return self._backend.create_channel(self, channel_name, channel_type)
        elif channel_namespace == ChannelNamespace.SYSTEM:
            return self._backend.create_system_channel(self, channel_name, channel_type)
        else:
            raise RuntimeError(&#34;Unknown channel namespace {}&#34;.format(channel_namespace))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="neptune.experiments.Experiment"><code class="flex name class">
<span>class <span class="ident">Experiment</span></span>
<span>(</span><span>backend, project, _id, internal_id)</span>
</code></dt>
<dd>
<div class="desc"><p>A class for managing Neptune experiment.</p>
<p>Each time User creates new experiment instance of this class is created.
It lets you manage experiment, :meth:<code>~neptune.experiments.Experiment.log_metric</code>,
:meth:<code>~neptune.experiments.Experiment.log_text</code>,
:meth:<code>~neptune.experiments.Experiment.log_image</code>,
:meth:<code>~neptune.experiments.Experiment.set_property</code>,
and much more.</p>
<h2 id="args">Args</h2>
<p>backend (:obj:<code>neptune.Backend</code>): A Backend object
project (:obj:<code>neptune.Project</code>): The project this experiment belongs to
_id (:obj:<code>str</code>): Experiment id
internal_id (:obj:<code>str</code>): internal UUID</p>
<h2 id="example">Example</h2>
<p>Assuming that <code>project</code> is an instance of :class:<code>~neptune.projects.Project</code>.</p>
<div class="admonition code">
<p class="admonition-title">Code:&ensp;python3</p>
<p>experiment = project.create_experiment()</p>
</div>
<h2 id="warning">Warning</h2>
<p>User should never create instances of this class manually.
Always use: :meth:<code>~neptune.projects.Project.create_experiment</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Experiment(object):
    &#34;&#34;&#34;A class for managing Neptune experiment.

    Each time User creates new experiment instance of this class is created.
    It lets you manage experiment, :meth:`~neptune.experiments.Experiment.log_metric`,
    :meth:`~neptune.experiments.Experiment.log_text`,
    :meth:`~neptune.experiments.Experiment.log_image`,
    :meth:`~neptune.experiments.Experiment.set_property`,
    and much more.


    Args:
        backend (:obj:`neptune.Backend`): A Backend object
        project (:obj:`neptune.Project`): The project this experiment belongs to
        _id (:obj:`str`): Experiment id
        internal_id (:obj:`str`): internal UUID

    Example:
        Assuming that `project` is an instance of :class:`~neptune.projects.Project`.

        .. code:: python3

            experiment = project.create_experiment()

    Warning:
        User should never create instances of this class manually.
        Always use: :meth:`~neptune.projects.Project.create_experiment`.

    &#34;&#34;&#34;

    IMAGE_SIZE_LIMIT_MB = 15

    def __init__(self, backend, project, _id, internal_id):
        self._backend = backend
        self._project = project
        self._id = _id
        self._internal_id = internal_id
        self._channels_values_sender = ChannelsValuesSender(self)
        self._execution_context = ExecutionContext(backend, self)

    @property
    def id(self):
        &#34;&#34;&#34;Experiment short id

        | Combination of project key and unique experiment number.
        | Format is ``&lt;project_key&gt;-&lt;experiment_number&gt;``, for example: ``MPI-142``.

        Returns:
            :obj:`str` - experiment short id

        Examples:
            Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`.

            .. code:: python3

                exp_id = experiment.id

        &#34;&#34;&#34;
        return self._id

    @property
    def name(self):
        &#34;&#34;&#34;Experiment name

        Returns:
            :obj:`str` experiment name

        Examples:
            Assuming that `project` is an instance of :class:`~neptune.projects.Project`.

            .. code:: python3

                experiment = project.create_experiment(&#39;exp_name&#39;)
                exp_name = experiment.name
        &#34;&#34;&#34;
        return self._backend.get_experiment(self._internal_id).name

    @property
    def state(self):
        &#34;&#34;&#34;Current experiment state

        Possible values: `&#39;running&#39;`, `&#39;succeeded&#39;`, `&#39;failed&#39;`, `&#39;aborted&#39;`.

        Returns:
            :obj:`str` - current experiment state

        Examples:
            Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`.

            .. code:: python3

                state_str = experiment.state
        &#34;&#34;&#34;
        return self._backend.get_experiment(self._internal_id).state

    @property
    def internal_id(self):
        return self._internal_id

    @property
    def limits(self):
        return {
            &#39;channels&#39;: {
                &#39;numeric&#39;: 1000,
                &#39;text&#39;: 100,
                &#39;image&#39;: 100
            }
        }

    def get_system_properties(self):
        &#34;&#34;&#34;Retrieve experiment properties.

        | Experiment properties are for example: `owner`, `created`, `name`, `hostname`.
        | List of experiment properties may change over time.

        Returns:
            :obj:`dict` - dictionary mapping a property name to value.

        Examples:
            Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`.

            .. code:: python3

                sys_properties = experiment.get_system_properties
        &#34;&#34;&#34;
        experiment = self._backend.get_experiment(self._internal_id)
        return {
            &#39;id&#39;: experiment.shortId,
            &#39;name&#39;: experiment.name,
            &#39;created&#39;: experiment.timeOfCreation,
            &#39;finished&#39;: experiment.timeOfCompletion,
            &#39;running_time&#39;: experiment.runningTime,
            &#39;owner&#39;: experiment.owner,
            &#39;storage_size&#39;: experiment.storageSize,
            &#39;channels_size&#39;: experiment.channelsSize,
            &#39;size&#39;: experiment.storageSize + experiment.channelsSize,
            &#39;tags&#39;: experiment.tags,
            &#39;notes&#39;: experiment.description,
            &#39;description&#39;: experiment.description,
            &#39;hostname&#39;: experiment.hostname
        }

    def get_tags(self):
        &#34;&#34;&#34;Get tags associated with experiment.

        Returns:
            :obj:`list` of :obj:`str` with all tags for this experiment.

        Example:
            Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`.

            .. code:: python3

                experiment.get_tags()
        &#34;&#34;&#34;
        return self._backend.get_experiment(self._internal_id).tags

    def append_tag(self, tag, *tags):
        &#34;&#34;&#34;Append tag(s) to the current experiment.

        Alias: :meth:`~neptune.experiments.Experiment.append_tags`.
        Only ``[a-zA-Z0-9]`` and ``-`` (dash) characters are allowed in tags.

        Args:
            tag (single :obj:`str` or multiple :obj:`str` or :obj:`list` of :obj:`str`):
                Tag(s) to add to the current experiment.

                    * If :obj:`str` is passed, singe tag is added.
                    * If multiple - comma separated - :obj:`str` are passed, all of them are added as tags.
                    * If :obj:`list` of :obj:`str` is passed, all elements of the :obj:`list` are added as tags.

        Examples:

            .. code:: python3

                neptune.append_tag(&#39;new-tag&#39;)  # single tag
                neptune.append_tag(&#39;first-tag&#39;, &#39;second-tag&#39;, &#39;third-tag&#39;)  # few str
                neptune.append_tag([&#39;first-tag&#39;, &#39;second-tag&#39;, &#39;third-tag&#39;])  # list of str
        &#34;&#34;&#34;
        if isinstance(tag, list):
            tags_list = tag
        else:
            tags_list = [tag] + list(tags)
        self._backend.update_tags(experiment=self,
                                  tags_to_add=tags_list,
                                  tags_to_delete=[])

    def append_tags(self, tag, *tags):
        &#34;&#34;&#34;Append tag(s) to the current experiment.

        Alias for: :meth:`~neptune.experiments.Experiment.append_tag`
        &#34;&#34;&#34;
        self.append_tag(tag, *tags)

    def remove_tag(self, tag):
        &#34;&#34;&#34;Removes single tag from the experiment.

        Args:
            tag (:obj:`str`): Tag to be removed

        Example:
            Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`.

            .. code:: python3

                # assuming experiment has tags: `[&#39;tag-1&#39;, &#39;tag-2&#39;]`.
                experiment.remove_tag(&#39;tag-1&#39;)

        Note:
            Removing a tag that is not assigned to this experiment is silently ignored.
        &#34;&#34;&#34;
        self._backend.update_tags(experiment=self,
                                  tags_to_add=[],
                                  tags_to_delete=[tag])

    def get_channels(self):
        &#34;&#34;&#34;Alias for :meth:`~neptune.experiments.Experiment.get_logs`
        &#34;&#34;&#34;
        return self.get_logs()

    def get_logs(self):
        &#34;&#34;&#34;Retrieve all log names along with their last values for this experiment.

        Returns:
            :obj:`dict` - A dictionary mapping a log names to the log&#39;s last value.

        Example:
            Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`.

            .. code:: python3

                exp_logs = experiment.get_logs()
        &#34;&#34;&#34;
        experiment = self._backend.get_experiment(self.internal_id)
        channels_last_values_by_name = dict((ch.channelName, ch) for ch in experiment.channelsLastValues)
        channels = dict()
        for ch in experiment.channels:
            last_value = channels_last_values_by_name.get(ch.name, None)
            if last_value is not None:
                ch.x = last_value.x
                ch.y = last_value.y
            elif ch.lastX is not None:
                ch.x = ch.lastX
                ch.y = None
            else:
                ch.x = None
                ch.y = None
            channels[ch.name] = ch
        return channels

    def _get_system_channels(self):
        channels = self._backend.get_system_channels(self)
        return dict((ch.name, ch) for ch in channels)

    def send_metric(self, channel_name, x, y=None, timestamp=None):
        &#34;&#34;&#34;Log metrics (numeric values) in Neptune.

        Alias for :meth:`~neptune.experiments.Experiment.log_metric`
        &#34;&#34;&#34;
        return self.log_metric(channel_name, x, y, timestamp)

    def log_metric(self, log_name, x, y=None, timestamp=None):
        &#34;&#34;&#34;Log metrics (numeric values) in Neptune

        | If a log with provided ``log_name`` does not exist, it is created automatically.
        | If log exists (determined by ``log_name``), then new value is appended to it.

        Args:
            log_name (:obj:`str`): The name of log, i.e. `mse`, `loss`, `accuracy`.
            x (:obj:`double`): Depending, whether ``y`` parameter is passed:

                * ``y`` not passed: The value of the log (data-point).
                * ``y`` passed: Index of log entry being appended. Must be strictly increasing.

            y (:obj:`double`, optional, default is ``None``): The value of the log (data-point).
            timestamp (:obj:`time`, optional, default is ``None``):
                Timestamp to be associated with log entry. Must be Unix time.
                If ``None`` is passed, `time.time() &lt;https://docs.python.org/3.6/library/time.html#time.time&gt;`_
                (Python 3.6 example) is invoked to obtain timestamp.

        Example:
            Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment` and
            &#39;accuracy&#39; log does not exists:

            .. code:: python3

                # Both calls below have the same effect

                # Common invocation, providing log name and value
                experiment.log_metric(&#39;accuracy&#39;, 0.5)
                experiment.log_metric(&#39;accuracy&#39;, 0.65)
                experiment.log_metric(&#39;accuracy&#39;, 0.8)

                # Providing both x and y params
                experiment.log_metric(&#39;accuracy&#39;, 0, 0.5)
                experiment.log_metric(&#39;accuracy&#39;, 1, 0.65)
                experiment.log_metric(&#39;accuracy&#39;, 2, 0.8)

        Note:
            For efficiency, logs are uploaded in batches via a queue.
            Hence, if you log a lot of data, you may experience slight delays in Neptune web application.
        Note:
            Passing either ``x`` or ``y`` coordinate as NaN or +/-inf causes this log entry to be ignored.
            Warning is printed to ``stdout``.
        &#34;&#34;&#34;
        x, y = self._get_valid_x_y(x, y)

        if not is_float(y):
            raise InvalidChannelValue(expected_type=&#39;float&#39;, actual_type=type(y).__name__)

        if is_nan_or_inf(y):
            _logger.warning(
                &#39;Invalid metric value: %s for channel %s. &#39;
                &#39;Metrics with nan or +/-inf values will not be sent to server&#39;,
                y,
                log_name)
        elif x is not None and is_nan_or_inf(x):
            _logger.warning(
                &#39;Invalid metric x-coordinate: %s for channel %s. &#39;
                &#39;Metrics with nan or +/-inf x-coordinates will not be sent to server&#39;,
                x,
                log_name)
        else:
            value = ChannelValue(x, dict(numeric_value=y), timestamp)
            self._channels_values_sender.send(log_name, ChannelType.NUMERIC.value, value)

    def send_text(self, channel_name, x, y=None, timestamp=None):
        &#34;&#34;&#34;Log text data in Neptune.

        Alias for :meth:`~neptune.experiments.Experiment.log_text`
        &#34;&#34;&#34;
        return self.log_text(channel_name, x, y, timestamp)

    def log_text(self, log_name, x, y=None, timestamp=None):
        &#34;&#34;&#34;Log text data in Neptune

        | If a log with provided ``log_name`` does not exist, it is created automatically.
        | If log exists (determined by ``log_name``), then new value is appended to it.

        Args:
            log_name (:obj:`str`): The name of log, i.e. `mse`, `my_text_data`, `timing_info`.
            x (:obj:`double` or :obj:`str`): Depending, whether ``y`` parameter is passed:

                * ``y`` not passed: The value of the log (data-point). Must be ``str``.
                * ``y`` passed: Index of log entry being appended. Must be strictly increasing.

            y (:obj:`str`, optional, default is ``None``): The value of the log (data-point).
            timestamp (:obj:`time`, optional, default is ``None``):
                Timestamp to be associated with log entry. Must be Unix time.
                If ``None`` is passed, `time.time() &lt;https://docs.python.org/3.6/library/time.html#time.time&gt;`_
                (Python 3.6 example) is invoked to obtain timestamp.

        Example:
            Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`:

            .. code:: python3

                # common case, where log name and data are passed
                neptune.log_text(&#39;my_text_data&#39;, str(data_item))

                # log_name, x and timestamp are passed
                neptune.log_text(log_name=&#39;logging_losses_as_text&#39;,
                                 x=str(val_loss),
                                 timestamp=1560430912)

        Note:
            For efficiency, logs are uploaded in batches via a queue.
            Hence, if you log a lot of data, you may experience slight delays in Neptune web application.
        Note:
            Passing ``x`` coordinate as NaN or +/-inf causes this log entry to be ignored.
            Warning is printed to ``stdout``.
        &#34;&#34;&#34;
        x, y = self._get_valid_x_y(x, y)

        if x is not None and is_nan_or_inf(x):
            x = None

        if not isinstance(y, six.string_types):
            raise InvalidChannelValue(expected_type=&#39;str&#39;, actual_type=type(y).__name__)

        if x is not None and is_nan_or_inf(x):
            _logger.warning(
                &#39;Invalid metric x-coordinate: %s for channel %s. &#39;
                &#39;Metrics with nan or +/-inf x-coordinates will not be sent to server&#39;,
                x,
                log_name)
        else:
            value = ChannelValue(x, dict(text_value=y), timestamp)
            self._channels_values_sender.send(log_name, ChannelType.TEXT.value, value)

    def send_image(self, channel_name, x, y=None, name=None, description=None, timestamp=None):
        &#34;&#34;&#34;Log image data in Neptune.

        Alias for :meth:`~neptune.experiments.Experiment.log_image`
        &#34;&#34;&#34;
        return self.log_image(channel_name, x, y, name, description, timestamp)

    def log_image(self, log_name, x, y=None, image_name=None, description=None, timestamp=None):
        &#34;&#34;&#34;Log image data in Neptune

        | If a log with provided ``log_name`` does not exist, it is created automatically.
        | If log exists (determined by ``log_name``), then new value is appended to it.

        Args:
            log_name (:obj:`str`): The name of log, i.e. `bboxes`, `visualisations`, `sample_images`.
            x (:obj:`double`): Depending, whether ``y`` parameter is passed:

                * ``y`` not passed: The value of the log (data-point). See ``y`` parameter.
                * ``y`` passed: Index of log entry being appended. Must be strictly increasing.

            y (multiple types supported, optional, default is ``None``):

                The value of the log (data-point). Can be one of the following types:

                * :obj:`PIL image`
                  `Pillow docs &lt;https://pillow.readthedocs.io/en/latest/reference/Image.html#image-module&gt;`_
                * :obj:`matplotlib.figure.Figure`
                  `Matplotlib 3.1.1 docs &lt;https://matplotlib.org/3.1.1/api/_as_gen/matplotlib.figure.Figure.html&gt;`_
                * :obj:`str` - path to image file
                * 2-dimensional :obj:`numpy.array` - interpreted as grayscale image
                * 3-dimensional :obj:`numpy.array` - behavior depends on last dimension

                    * if last dimension is 1 - interpreted as grayscale image
                    * if last dimension is 3 - interpreted as RGB image
                    * if last dimension is 4 - interpreted as RGBA image

            image_name (:obj:`str`, optional, default is ``None``): Image name
            description (:obj:`str`, optional, default is ``None``): Image description
            timestamp (:obj:`time`, optional, default is ``None``):
                Timestamp to be associated with log entry. Must be Unix time.
                If ``None`` is passed, `time.time() &lt;https://docs.python.org/3.6/library/time.html#time.time&gt;`_
                (Python 3.6 example) is invoked to obtain timestamp.

        Example:
            Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`:

            .. code:: python3

                # path to image file
                experiment.log_image(&#39;bbox_images&#39;, &#39;pictures/image.png&#39;)
                experiment.log_image(&#39;bbox_images&#39;, x=5, &#39;pictures/image.png&#39;)
                experiment.log_image(&#39;bbox_images&#39;, &#39;pictures/image.png&#39;, image_name=&#39;difficult_case&#39;)

                # PIL image
                img = PIL.Image.new(&#39;RGB&#39;, (60, 30), color = &#39;red&#39;)
                experiment.log_image(&#39;fig&#39;, img)

                # 2d numpy array
                array = numpy.random.rand(300, 200)*255
                experiment.log_image(&#39;fig&#39;, array)

                # 3d grayscale array
                array = numpy.random.rand(300, 200, 1)*255
                experiment.log_image(&#39;fig&#39;, array)

                # 3d RGB array
                array = numpy.random.rand(300, 200, 3)*255
                experiment.log_image(&#39;fig&#39;, array)

                # 3d RGBA array
                array = numpy.random.rand(300, 200, 4)*255
                experiment.log_image(&#39;fig&#39;, array)

                # matplotlib figure example 1
                from matplotlib import pyplot
                pyplot.plot([1, 2, 3, 4])
                pyplot.ylabel(&#39;some numbers&#39;)
                experiment.log_image(&#39;plots&#39;, plt.gcf())

                # matplotlib figure example 2
                from matplotlib import pyplot
                import numpy

                numpy.random.seed(19680801)
                data = numpy.random.randn(2, 100)

                figure, axs = pyplot.subplots(2, 2, figsize=(5, 5))
                axs[0, 0].hist(data[0])
                axs[1, 0].scatter(data[0], data[1])
                axs[0, 1].plot(data[0], data[1])
                axs[1, 1].hist2d(data[0], data[1])

                experiment.log_image(&#39;diagrams&#39;, figure)

        Note:
            For efficiency, logs are uploaded in batches via a queue.
            Hence, if you log a lot of data, you may experience slight delays in Neptune web application.
        Note:
            Passing ``x`` coordinate as NaN or +/-inf causes this log entry to be ignored.
            Warning is printed to ``stdout``.
        Warning:
            Only images up to 15MB are supported. Larger files will not be logged to Neptune.
        &#34;&#34;&#34;
        x, y = self._get_valid_x_y(x, y)

        if x is not None and is_nan_or_inf(x):
            x = None

        image_content = get_image_content(y)
        if len(image_content) &gt; self.IMAGE_SIZE_LIMIT_MB * 1024 * 1024:
            _logger.warning(&#39;Your image is larger than %dMB. Neptune supports logging images smaller than %dMB. &#39;
                            &#39;Resize or increase compression of this image&#39;,
                            self.IMAGE_SIZE_LIMIT_MB,
                            self.IMAGE_SIZE_LIMIT_MB)
            image_content = None

        input_image = dict(
            name=image_name,
            description=description
        )
        if image_content:
            input_image[&#39;data&#39;] = base64.b64encode(image_content).decode(&#39;utf-8&#39;)

        if x is not None and is_nan_or_inf(x):
            _logger.warning(
                &#39;Invalid metric x-coordinate: %s for channel %s. &#39;
                &#39;Metrics with nan or +/-inf x-coordinates will not be sent to server&#39;,
                x,
                log_name)
        else:
            value = ChannelValue(x, dict(image_value=input_image), timestamp)
            self._channels_values_sender.send(log_name, ChannelType.IMAGE.value, value)

    def send_artifact(self, artifact, destination=None):
        &#34;&#34;&#34;Save an artifact (file) in experiment storage.

        Alias for :meth:`~neptune.experiments.Experiment.log_artifact`
        &#34;&#34;&#34;
        return self.log_artifact(artifact, destination)

    def log_artifact(self, artifact, destination=None):
        &#34;&#34;&#34;Save an artifact (file) in experiment storage.

        Args:
            artifact (:obj:`str` or :obj:`IO object`):
                A path to the file in local filesystem or IO object. It can be open
                file descriptor or in-memory buffer like `io.StringIO` or `io.BytesIO`.
            destination (:obj:`str`, optional, default is ``None``):
                A destination path.
                If ``None`` is passed, an artifact file name will be used.

        Raises:
            `FileNotFound`: When ``artifact`` file was not found.
            `StorageLimitReached`: When storage limit in the project has been reached.

        Example:
            Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`:

            .. code:: python3

                # simple use
                experiment.log_artifact(&#39;images/wrong_prediction_1.png&#39;)

                # save file in other directory
                experiment.log_artifact(&#39;images/wrong_prediction_1.png&#39;, &#39;validation/images/wrong_prediction_1.png&#39;)

                # save file under different name
                experiment.log_artifact(&#39;images/wrong_prediction_1.png&#39;, &#39;images/my_image_1.png&#39;)
        &#34;&#34;&#34;
        if isinstance(artifact, str):
            if os.path.exists(artifact):
                target_name = os.path.basename(artifact) if destination is None else destination
                upload_entry = UploadEntry(os.path.abspath(artifact), normalize_file_name(target_name))
            else:
                raise FileNotFound(artifact)
        elif hasattr(artifact, &#39;read&#39;):
            if destination is not None:
                upload_entry = UploadEntry(artifact, normalize_file_name(destination))
            else:
                raise ValueError(&#34;destination is required for file streams&#34;)
        else:
            raise ValueError(&#34;artifact is a local path or an IO object&#34;)

        upload_to_storage(upload_entries=[upload_entry],
                          upload_api_fun=self._backend.upload_experiment_output,
                          upload_tar_api_fun=self._backend.extract_experiment_output,
                          experiment=self)

    def delete_artifacts(self, path):
        &#34;&#34;&#34;Removes an artifact(s) (file/directory) from the experiment storage.

        Args:
            path (:obj:`list` or :obj:`str`): Path or list of paths to remove from the experiment&#39;s output

        Raises:
            `FileNotFound`: If a path in experiment artifacts does not exist.

        Examples:
            Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`.

            .. code:: python3

                experiment.delete_artifacts(&#39;forest_results.pkl&#39;)
                experiment.delete_artifacts([&#39;forest_results.pkl&#39;, &#39;directory&#39;])
                experiment.delete_artifacts(&#39;&#39;)
        &#34;&#34;&#34;
        if path is None:
            raise ValueError(&#34;path argument must not be None&#34;)

        paths = path
        if not isinstance(path, list):
            paths = [path]
        for path in paths:
            if path is None:
                raise ValueError(&#34;path argument must not be None&#34;)
            normalized_path = os.path.normpath(path)
            if normalized_path.startswith(&#34;..&#34;):
                raise ValueError(&#34;path to delete must be within project&#39;s directory&#34;)
            if normalized_path == &#34;.&#34; or normalized_path == &#34;/&#34; or not normalized_path:
                raise ValueError(&#34;Cannot delete whole artifacts directory&#34;)
        try:
            for path in paths:
                self._backend.rm_data(experiment=self, path=path)
        except PathInProjectNotFound:
            raise FileNotFound(path)

    def download_artifact(self, path, destination_dir=None):
        &#34;&#34;&#34;Download an artifact (file) from the experiment storage.

        Download a file indicated by ``path`` from the experiment artifacts and save it in ``destination_dir``.

        Args:
            path (:obj:`str`): Path to the file to be downloaded.
            destination_dir (:obj:`str`):
                The directory where the file will be downloaded.
                If ``None`` is passed, the file will be downloaded to the current working directory.

        Raises:
            `NotADirectory`: When ``destination_dir`` is not a directory.
            `FileNotFound`: If a path in experiment artifacts does not exist.

        Examples:
            Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`.

            .. code:: python3

                experiment.download_artifact(&#39;forest_results.pkl&#39;, &#39;/home/user/files/&#39;)
        &#34;&#34;&#34;
        if not destination_dir:
            destination_dir = os.getcwd()

        project_storage_path = &#34;/{exp_id}/output/{file}&#34;.format(exp_id=self.id, file=path)
        destination_path = os.path.join(destination_dir, os.path.basename(path))

        if not os.path.exists(destination_dir):
            os.makedirs(destination_dir)
        elif not os.path.isdir(destination_dir):
            raise NotADirectory(destination_dir)

        try:
            self._backend.download_data(self._project, project_storage_path, destination_path)
        except PathInProjectNotFound:
            raise FileNotFound(path)

    def download_sources(self, path=None, destination_dir=None):
        &#34;&#34;&#34;Download a directory or a single file from experiment&#39;s sources as a ZIP archive.

        Download a subdirectory (or file) ``path`` from the experiment sources and save it in ``destination_dir``
        as a ZIP archive. The name of an archive will be a name of downloaded directory (or file) with &#39;.zip&#39; extension.

        Args:
            path (:obj:`str`):
                Path of a directory or file in experiment sources to be downloaded.
                If ``None`` is passed, all source files will be downloaded.

            destination_dir (:obj:`str`): The directory where the archive will be downloaded.
                If ``None`` is passed, the archive will be downloaded to the current working directory.

        Raises:
            `NotADirectory`: When ``destination_dir`` is not a directory.
            `FileNotFound`: If a path in experiment sources does not exist.

        Examples:
            Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`.

            .. code:: python3

                # Download all experiment sources to current working directory
                experiment.download_sources()

                # Download a single directory
                experiment.download_sources(&#39;src/my-module&#39;)

                # Download all experiment sources to user-defined directory
                experiment.download_sources(destination_dir=&#39;/tmp/sources/&#39;)

                # Download a single directory to user-defined directory
                experiment.download_sources(&#39;src/my-module&#39;, &#39;sources/&#39;)
        &#34;&#34;&#34;
        if not path:
            path = &#34;&#34;
        if not destination_dir:
            destination_dir = os.getcwd()

        if not os.path.exists(destination_dir):
            os.makedirs(destination_dir)
        elif not os.path.isdir(destination_dir):
            raise NotADirectory(destination_dir)

        download_request = self._backend.prepare_source_download_reuqest(self, path)
        self._download_from_request(download_request, destination_dir, path)

    def download_artifacts(self, path=None, destination_dir=None):
        &#34;&#34;&#34;Download a directory or a single file from experiment&#39;s artifacts as a ZIP archive.

        Download a subdirectory (or file) ``path`` from the experiment artifacts and save it in ``destination_dir``
        as a ZIP archive. The name of an archive will be a name of downloaded directory (or file) with &#39;.zip&#39; extension.

        Args:
            path (:obj:`str`):
                Path of a directory or file in experiment artifacts to be downloaded.
                If ``None`` is passed, all artifacts will be downloaded.

            destination_dir (:obj:`str`): The directory where the archive will be downloaded.
                If ``None`` is passed, the archive will be downloaded to the current working directory.

        Raises:
            `NotADirectory`: When ``destination_dir`` is not a directory.
            `FileNotFound`: If a path in experiment artifacts does not exist.

        Examples:
            Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`.

            .. code:: python3

                # Download all experiment artifacts to current working directory
                experiment.download_artifacts()

                # Download a single directory
                experiment.download_artifacts(&#39;data/images&#39;)

                # Download all experiment artifacts to user-defined directory
                experiment.download_artifacts(destination_dir=&#39;/tmp/artifacts/&#39;)

                # Download a single directory to user-defined directory
                experiment.download_artifacts(&#39;data/images&#39;, &#39;artifacts/&#39;)
        &#34;&#34;&#34;
        if not path:
            path = &#34;&#34;
        if not destination_dir:
            destination_dir = os.getcwd()

        if not os.path.exists(destination_dir):
            os.makedirs(destination_dir)
        elif not os.path.isdir(destination_dir):
            raise NotADirectory(destination_dir)

        download_request = self._backend.prepare_output_download_reuqest(self, path)
        self._download_from_request(download_request, destination_dir, path)

    def _download_from_request(self, download_request, destination_dir, path):
        sleep_time = 1
        max_sleep_time = 16
        while not hasattr(download_request, &#34;downloadUrl&#34;):
            time.sleep(sleep_time)
            sleep_time = min(sleep_time * 2, max_sleep_time)
            download_request = self._backend.get_download_request(download_request.id)

        ssl_verify = True
        if os.getenv(&#34;NEPTUNE_ALLOW_SELF_SIGNED_CERTIFICATE&#34;):
            ssl_verify = False

        # We do not use Backend here cause `downloadUrl` can be any url (not only Neptune API endpoint)
        response = requests.get(
            url=download_request.downloadUrl,
            headers={&#34;Accept&#34;: &#34;application/zip&#34;},
            stream=True,
            verify=ssl_verify
        )

        with response:
            filename = None
            if &#39;content-disposition&#39; in response.headers:
                content_disposition = response.headers[&#39;content-disposition&#39;]
                filenames = re.findall(&#34;filename=(.+)&#34;, content_disposition)
                if filenames:
                    filename = filenames[0]

            if not filename:
                filename = os.path.basename(path.rstrip(&#34;/&#34;)) + &#34;.zip&#34;

            destination_path = os.path.join(destination_dir, filename)
            with open(destination_path, &#34;wb&#34;) as f:
                for chunk in response.iter_content(chunk_size=10 * 1024 * 1024):
                    if chunk:
                        f.write(chunk)

    def reset_log(self, log_name):
        &#34;&#34;&#34;Resets the log.

        Removes all data from the log and enables it to be reused from scratch.

        Args:
            log_name (:obj:`str`): The name of log to reset.

        Raises:
            `ChannelDoesNotExist`: When the log with name ``log_name`` does not exist on the server.

        Example:
            Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`.

            .. code:: python3

                experiment.reset_log(&#39;my_metric&#39;)

        Note:
            Check Neptune web application to see that reset charts have no data.
        &#34;&#34;&#34;
        channel = self._find_channel(log_name, ChannelNamespace.USER)
        if channel is None:
            raise ChannelDoesNotExist(self.id, log_name)
        self._backend.reset_channel(channel.id)

    def get_parameters(self):
        &#34;&#34;&#34;Retrieve parameters for this experiment.

        Returns:
            :obj:`dict` - dictionary mapping a parameter name to value.

        Examples:
            Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`.

            .. code:: python3

                exp_params = experiment.get_parameters()
        &#34;&#34;&#34;
        experiment = self._backend.get_experiment(self.internal_id)
        return dict((p.name, self._convert_parameter_value(p.value, p.parameterType)) for p in experiment.parameters)

    def get_properties(self):
        &#34;&#34;&#34;Retrieve User-defined properties for this experiment.

        Returns:
            :obj:`dict` - dictionary mapping a property key to value.

        Examples:
            Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`.

            .. code:: python3

                exp_properties = experiment.get_properties()
        &#34;&#34;&#34;
        experiment = self._backend.get_experiment(self.internal_id)
        return dict((p.key, p.value) for p in experiment.properties)

    def set_property(self, key, value):
        &#34;&#34;&#34;Set `key-value` pair as an experiment property.

        If property with given ``key`` does not exist, it adds a new one.

        Args:
            key (:obj:`str`): Property key.
            value (:obj:`obj`): New value of a property.

        Examples:
            Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`:

            .. code:: python3

                experiment.set_property(&#39;model&#39;, &#39;LightGBM&#39;)
                experiment.set_property(&#39;magic-number&#39;, 7)
        &#34;&#34;&#34;
        properties = {p.key: p.value for p in self._backend.get_experiment(self.internal_id).properties}
        properties[key] = str(value)
        return self._backend.update_experiment(
            experiment=self,
            properties=properties
        )

    def remove_property(self, key):
        &#34;&#34;&#34;Removes a property with given key.

        Args:
            key (single :obj:`str`):
                Key of property to remove.

        Examples:
            Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`:

            .. code:: python3

                experiment.remove_property(&#39;host&#39;)
        &#34;&#34;&#34;
        properties = {p.key: p.value for p in self._backend.get_experiment(self.internal_id).properties}
        del properties[key]
        return self._backend.update_experiment(
            experiment=self,
            properties=properties
        )

    def get_hardware_utilization(self):
        &#34;&#34;&#34;Retrieve GPU, CPU and memory utilization data.

        Get hardware utilization metrics for entire experiment as a single
        `pandas.DataFrame &lt;https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html&gt;`_
        object. Returned DataFrame has following columns (assuming single GPU with 0 index):

            * `x_ram` - time (in milliseconds) from the experiment start,
            * `y_ram` - memory usage in GB,
            * `x_cpu` - time (in milliseconds) from the experiment start,
            * `y_cpu` - CPU utilization percentage (0-100),
            * `x_gpu_util_0` - time (in milliseconds) from the experiment start,
            * `y_gpu_util_0` - GPU utilization percentage (0-100),
            * `x_gpu_mem_0` - time (in milliseconds) from the experiment start,
            * `y_gpu_mem_0` - GPU memory usage in GB.

        | If more GPUs are available they have their separate columns with appropriate indices (0, 1, 2, ...),
          for example: `x_gpu_util_1`, `y_gpu_util_1`.
        | The returned DataFrame may contain ``NaN`` s if one of the metrics has more values than others.

        Returns:
            :obj:`pandas.DataFrame` - DataFrame containing the hardware utilization metrics.

        Examples:
            The following values denote that after 3 seconds, the experiment used 16.7 GB of RAM

                * `x_ram` = 3000
                * `y_ram` = 16.7

            Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`:

            .. code:: python3

                hardware_df = experiment.get_hardware_utilization()
        &#34;&#34;&#34;
        metrics_csv = self._backend.get_metrics_csv(self)
        try:
            return pd.read_csv(metrics_csv)
        except EmptyDataError:
            return pd.DataFrame()

    def get_numeric_channels_values(self, *channel_names):
        &#34;&#34;&#34;Retrieve values of specified metrics (numeric logs).

        The returned
        `pandas.DataFrame &lt;https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html&gt;`_
        contains 1 additional column `x` along with the requested metrics.

        Args:
            *channel_names (one or more :obj:`str`): comma-separated metric names.

        Returns:
            :obj:`pandas.DataFrame` - DataFrame containing values for the requested metrics.

            | The returned DataFrame may contain ``NaN`` s if one of the metrics has more values than others.

        Example:
            Invoking ``get_numeric_channels_values(&#39;loss&#39;, &#39;auc&#39;)`` returns DataFrame with columns
            `x`, `loss`, `auc`.

            Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`:

            .. code:: python3

                batch_channels = experiment.get_numeric_channels_values(&#39;batch-1-loss&#39;, &#39;batch-2-metric&#39;)
                epoch_channels = experiment.get_numeric_channels_values(&#39;epoch-1-loss&#39;, &#39;epoch-2-metric&#39;)

        Note:
            It&#39;s good idea to get metrics with common temporal pattern (like iteration or batch/epoch number).
            Thanks to this each row of returned DataFrame has metrics from the same moment in experiment.
            For example, combine epoch metrics to one DataFrame and batch metrics to the other.
        &#34;&#34;&#34;

        channels_data = {}
        channels_by_name = self.get_channels()
        for channel_name in channel_names:
            channel_id = channels_by_name[channel_name].id
            try:
                channels_data[channel_name] = pd.read_csv(
                    self._backend.get_channel_points_csv(self, channel_id),
                    header=None,
                    names=[&#39;x_{}&#39;.format(channel_name), &#39;y_{}&#39;.format(channel_name)],
                    dtype=float
                )
            except EmptyDataError:
                channels_data[channel_name] = pd.DataFrame(
                    columns=[&#39;x_{}&#39;.format(channel_name), &#39;y_{}&#39;.format(channel_name)],
                    dtype=float
                )

        return align_channels_on_x(pd.concat(channels_data.values(), axis=1, sort=False))

    def _start(self,
               upload_source_entries=None,
               abort_callback=None,
               logger=None,
               upload_stdout=True,
               upload_stderr=True,
               send_hardware_metrics=True,
               run_monitoring_thread=True,
               handle_uncaught_exceptions=True):
        upload_to_storage(upload_entries=upload_source_entries,
                          upload_api_fun=self._backend.upload_experiment_source,
                          upload_tar_api_fun=self._backend.extract_experiment_source,
                          warn_limit=100 * 1024 * 1024,
                          experiment=self)

        self._execution_context.start(
            abort_callback=abort_callback,
            logger=logger,
            upload_stdout=upload_stdout,
            upload_stderr=upload_stderr,
            send_hardware_metrics=send_hardware_metrics,
            run_monitoring_thread=run_monitoring_thread,
            handle_uncaught_exceptions=handle_uncaught_exceptions
        )

    def stop(self, exc_tb=None):
        &#34;&#34;&#34;Marks experiment as finished (succeeded or failed).

        Args:
            exc_tb (:obj:`str`, optional, default is ``None``): Additional traceback information
                to be stored in experiment details in case of failure (stacktrace, etc).
                If this argument is ``None`` the experiment will be marked as succeeded.
                Otherwise, experiment will be marked as failed.

        Examples:
            Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`:

            .. code:: python3

                # Marks experiment as succeeded
                experiment.stop()

                # Assuming &#39;ex&#39; is some exception,
                # it marks experiment as failed with exception info in experiment details.
                experiment.stop(str(ex))
        &#34;&#34;&#34;

        self._channels_values_sender.join()

        try:
            if exc_tb is None:
                self._backend.mark_succeeded(self)
            else:
                self._backend.mark_failed(self, exc_tb)
        except ExperimentAlreadyFinished:
            pass

        self._execution_context.stop()

        # pylint: disable=protected-access
        self._project._remove_stopped_experiment(self)

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        if exc_tb is None:
            self.stop()
        else:
            self.stop(&#34;\n&#34;.join(traceback.format_tb(exc_tb)) + &#34;\n&#34; + repr(exc_val))

    def __str__(self):
        return &#39;Experiment({})&#39;.format(self.id)

    def __repr__(self):
        return str(self)

    def __eq__(self, o):
        # pylint: disable=protected-access
        return self._id == o._id and self._internal_id == o._internal_id and self._project == o._project

    def __ne__(self, o):
        return not self.__eq__(o)

    @staticmethod
    def _convert_parameter_value(value, parameter_type):
        if parameter_type == &#39;double&#39;:
            return float(value)
        else:
            return value

    @staticmethod
    def _get_valid_x_y(x, y):
        &#34;&#34;&#34;
        The goal of this function is to allow user to call experiment.log_* with any of:
            - single parameter treated as y value
            - both parameters (named/unnamed)
            - single named y parameter
        If intended X-coordinate is provided, it is validated to be a float value
        &#34;&#34;&#34;
        if x is None and y is None:
            raise NoChannelValue()

        if x is None and y is not None:
            return None, y

        if x is not None and y is None:
            return None, x

        if x is not None and y is not None:
            if not is_float(x):
                raise InvalidChannelValue(expected_type=&#39;float&#39;, actual_type=type(x).__name__)
            return x, y

    def _send_channels_values(self, channels_with_values):
        self._backend.send_channels_values(self, channels_with_values)

    def _get_channels(self, channels_names_with_types):
        existing_channels = self.get_channels()
        channels_by_name = {}
        for (channel_name, channel_type) in channels_names_with_types:
            channel = existing_channels.get(channel_name, None)
            if channel is None:
                channel = self._create_channel(channel_name, channel_type)
            channels_by_name[channel.name] = channel
        return channels_by_name

    def _get_channel(self, channel_name, channel_type, channel_namespace=ChannelNamespace.USER):
        channel = self._find_channel(channel_name, channel_namespace)
        if channel is None:
            channel = self._create_channel(channel_name, channel_type, channel_namespace)
        return channel

    def _find_channel(self, channel_name, channel_namespace):
        if channel_namespace == ChannelNamespace.USER:
            return self.get_channels().get(channel_name, None)
        elif channel_namespace == ChannelNamespace.SYSTEM:
            return self._get_system_channels().get(channel_name, None)
        else:
            raise RuntimeError(&#34;Unknown channel namespace {}&#34;.format(channel_namespace))

    def _create_channel(self, channel_name, channel_type, channel_namespace=ChannelNamespace.USER):
        if channel_namespace == ChannelNamespace.USER:
            return self._backend.create_channel(self, channel_name, channel_type)
        elif channel_namespace == ChannelNamespace.SYSTEM:
            return self._backend.create_system_channel(self, channel_name, channel_type)
        else:
            raise RuntimeError(&#34;Unknown channel namespace {}&#34;.format(channel_namespace))</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="neptune.experiments.Experiment.IMAGE_SIZE_LIMIT_MB"><code class="name">var <span class="ident">IMAGE_SIZE_LIMIT_MB</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="neptune.experiments.Experiment.id"><code class="name">var <span class="ident">id</span></code></dt>
<dd>
<div class="desc"><p>Experiment short id</p>
<p>| Combination of project key and unique experiment number.
| Format is <code>&lt;project_key&gt;-&lt;experiment_number&gt;</code>, for example: <code>MPI-142</code>.</p>
<h2 id="returns">Returns</h2>
<p>:obj:<code>str</code> - experiment short id</p>
<h2 id="examples">Examples</h2>
<p>Assuming that <code>experiment</code> is an instance of :class:<code>~neptune.experiments.Experiment</code>.</p>
<div class="admonition code">
<p class="admonition-title">Code:&ensp;python3</p>
<p>exp_id = experiment.id</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def id(self):
    &#34;&#34;&#34;Experiment short id

    | Combination of project key and unique experiment number.
    | Format is ``&lt;project_key&gt;-&lt;experiment_number&gt;``, for example: ``MPI-142``.

    Returns:
        :obj:`str` - experiment short id

    Examples:
        Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`.

        .. code:: python3

            exp_id = experiment.id

    &#34;&#34;&#34;
    return self._id</code></pre>
</details>
</dd>
<dt id="neptune.experiments.Experiment.internal_id"><code class="name">var <span class="ident">internal_id</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def internal_id(self):
    return self._internal_id</code></pre>
</details>
</dd>
<dt id="neptune.experiments.Experiment.limits"><code class="name">var <span class="ident">limits</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def limits(self):
    return {
        &#39;channels&#39;: {
            &#39;numeric&#39;: 1000,
            &#39;text&#39;: 100,
            &#39;image&#39;: 100
        }
    }</code></pre>
</details>
</dd>
<dt id="neptune.experiments.Experiment.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Experiment name</p>
<h2 id="returns">Returns</h2>
<p>:obj:<code>str</code> experiment name</p>
<h2 id="examples">Examples</h2>
<p>Assuming that <code>project</code> is an instance of :class:<code>~neptune.projects.Project</code>.</p>
<div class="admonition code">
<p class="admonition-title">Code:&ensp;python3</p>
<p>experiment = project.create_experiment('exp_name')
exp_name = experiment.name</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self):
    &#34;&#34;&#34;Experiment name

    Returns:
        :obj:`str` experiment name

    Examples:
        Assuming that `project` is an instance of :class:`~neptune.projects.Project`.

        .. code:: python3

            experiment = project.create_experiment(&#39;exp_name&#39;)
            exp_name = experiment.name
    &#34;&#34;&#34;
    return self._backend.get_experiment(self._internal_id).name</code></pre>
</details>
</dd>
<dt id="neptune.experiments.Experiment.state"><code class="name">var <span class="ident">state</span></code></dt>
<dd>
<div class="desc"><p>Current experiment state</p>
<p>Possible values: <code>'running'</code>, <code>'succeeded'</code>, <code>'failed'</code>, <code>'aborted'</code>.</p>
<h2 id="returns">Returns</h2>
<p>:obj:<code>str</code> - current experiment state</p>
<h2 id="examples">Examples</h2>
<p>Assuming that <code>experiment</code> is an instance of :class:<code>~neptune.experiments.Experiment</code>.</p>
<div class="admonition code">
<p class="admonition-title">Code:&ensp;python3</p>
<p>state_str = experiment.state</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def state(self):
    &#34;&#34;&#34;Current experiment state

    Possible values: `&#39;running&#39;`, `&#39;succeeded&#39;`, `&#39;failed&#39;`, `&#39;aborted&#39;`.

    Returns:
        :obj:`str` - current experiment state

    Examples:
        Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`.

        .. code:: python3

            state_str = experiment.state
    &#34;&#34;&#34;
    return self._backend.get_experiment(self._internal_id).state</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="neptune.experiments.Experiment.append_tag"><code class="name flex">
<span>def <span class="ident">append_tag</span></span>(<span>self, tag, *tags)</span>
</code></dt>
<dd>
<div class="desc"><p>Append tag(s) to the current experiment.</p>
<p>Alias: :meth:<code>~neptune.experiments.Experiment.append_tags</code>.
Only <code>[a-zA-Z0-9]</code> and <code>-</code> (dash) characters are allowed in tags.</p>
<h2 id="args">Args</h2>
<p>tag (single :obj:<code>str</code> or multiple :obj:<code>str</code> or :obj:<code>list</code> of :obj:<code>str</code>):
Tag(s) to add to the current experiment.</p>
<pre><code>    * If :obj:&lt;code&gt;str&lt;/code&gt; is passed, singe tag is added.
    * If multiple - comma separated - :obj:&lt;code&gt;str&lt;/code&gt; are passed, all of them are added as tags.
    * If :obj:&lt;code&gt;list&lt;/code&gt; of :obj:&lt;code&gt;str&lt;/code&gt; is passed, all elements of the :obj:&lt;code&gt;list&lt;/code&gt; are added as tags.
</code></pre>
<h2 id="examples">Examples</h2>
<div class="admonition code">
<p class="admonition-title">Code:&ensp;python3</p>
<p>neptune.append_tag('new-tag')
# single tag
neptune.append_tag('first-tag', 'second-tag', 'third-tag')
# few str
neptune.append_tag(['first-tag', 'second-tag', 'third-tag'])
# list of str</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_tag(self, tag, *tags):
    &#34;&#34;&#34;Append tag(s) to the current experiment.

    Alias: :meth:`~neptune.experiments.Experiment.append_tags`.
    Only ``[a-zA-Z0-9]`` and ``-`` (dash) characters are allowed in tags.

    Args:
        tag (single :obj:`str` or multiple :obj:`str` or :obj:`list` of :obj:`str`):
            Tag(s) to add to the current experiment.

                * If :obj:`str` is passed, singe tag is added.
                * If multiple - comma separated - :obj:`str` are passed, all of them are added as tags.
                * If :obj:`list` of :obj:`str` is passed, all elements of the :obj:`list` are added as tags.

    Examples:

        .. code:: python3

            neptune.append_tag(&#39;new-tag&#39;)  # single tag
            neptune.append_tag(&#39;first-tag&#39;, &#39;second-tag&#39;, &#39;third-tag&#39;)  # few str
            neptune.append_tag([&#39;first-tag&#39;, &#39;second-tag&#39;, &#39;third-tag&#39;])  # list of str
    &#34;&#34;&#34;
    if isinstance(tag, list):
        tags_list = tag
    else:
        tags_list = [tag] + list(tags)
    self._backend.update_tags(experiment=self,
                              tags_to_add=tags_list,
                              tags_to_delete=[])</code></pre>
</details>
</dd>
<dt id="neptune.experiments.Experiment.append_tags"><code class="name flex">
<span>def <span class="ident">append_tags</span></span>(<span>self, tag, *tags)</span>
</code></dt>
<dd>
<div class="desc"><p>Append tag(s) to the current experiment.</p>
<p>Alias for: :meth:<code>~neptune.experiments.Experiment.append_tag</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def append_tags(self, tag, *tags):
    &#34;&#34;&#34;Append tag(s) to the current experiment.

    Alias for: :meth:`~neptune.experiments.Experiment.append_tag`
    &#34;&#34;&#34;
    self.append_tag(tag, *tags)</code></pre>
</details>
</dd>
<dt id="neptune.experiments.Experiment.delete_artifacts"><code class="name flex">
<span>def <span class="ident">delete_artifacts</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes an artifact(s) (file/directory) from the experiment storage.</p>
<h2 id="args">Args</h2>
<p>path (:obj:<code>list</code> or :obj:<code>str</code>): Path or list of paths to remove from the experiment's output</p>
<h2 id="raises">Raises</h2>
<p><code>FileNotFound</code>: If a path in experiment artifacts does not exist.</p>
<h2 id="examples">Examples</h2>
<p>Assuming that <code>experiment</code> is an instance of :class:<code>~neptune.experiments.Experiment</code>.</p>
<div class="admonition code">
<p class="admonition-title">Code:&ensp;python3</p>
<p>experiment.delete_artifacts('forest_results.pkl')
experiment.delete_artifacts(['forest_results.pkl', 'directory'])
experiment.delete_artifacts('')</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_artifacts(self, path):
    &#34;&#34;&#34;Removes an artifact(s) (file/directory) from the experiment storage.

    Args:
        path (:obj:`list` or :obj:`str`): Path or list of paths to remove from the experiment&#39;s output

    Raises:
        `FileNotFound`: If a path in experiment artifacts does not exist.

    Examples:
        Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`.

        .. code:: python3

            experiment.delete_artifacts(&#39;forest_results.pkl&#39;)
            experiment.delete_artifacts([&#39;forest_results.pkl&#39;, &#39;directory&#39;])
            experiment.delete_artifacts(&#39;&#39;)
    &#34;&#34;&#34;
    if path is None:
        raise ValueError(&#34;path argument must not be None&#34;)

    paths = path
    if not isinstance(path, list):
        paths = [path]
    for path in paths:
        if path is None:
            raise ValueError(&#34;path argument must not be None&#34;)
        normalized_path = os.path.normpath(path)
        if normalized_path.startswith(&#34;..&#34;):
            raise ValueError(&#34;path to delete must be within project&#39;s directory&#34;)
        if normalized_path == &#34;.&#34; or normalized_path == &#34;/&#34; or not normalized_path:
            raise ValueError(&#34;Cannot delete whole artifacts directory&#34;)
    try:
        for path in paths:
            self._backend.rm_data(experiment=self, path=path)
    except PathInProjectNotFound:
        raise FileNotFound(path)</code></pre>
</details>
</dd>
<dt id="neptune.experiments.Experiment.download_artifact"><code class="name flex">
<span>def <span class="ident">download_artifact</span></span>(<span>self, path, destination_dir=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Download an artifact (file) from the experiment storage.</p>
<p>Download a file indicated by <code>path</code> from the experiment artifacts and save it in <code>destination_dir</code>.</p>
<h2 id="args">Args</h2>
<p>path (:obj:<code>str</code>): Path to the file to be downloaded.
destination_dir (:obj:<code>str</code>):
The directory where the file will be downloaded.
If <code>None</code> is passed, the file will be downloaded to the current working directory.</p>
<h2 id="raises">Raises</h2>
<p><code>NotADirectory</code>: When <code>destination_dir</code> is not a directory.
<code>FileNotFound</code>: If a path in experiment artifacts does not exist.</p>
<h2 id="examples">Examples</h2>
<p>Assuming that <code>experiment</code> is an instance of :class:<code>~neptune.experiments.Experiment</code>.</p>
<div class="admonition code">
<p class="admonition-title">Code:&ensp;python3</p>
<p>experiment.download_artifact('forest_results.pkl', '/home/user/files/')</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download_artifact(self, path, destination_dir=None):
    &#34;&#34;&#34;Download an artifact (file) from the experiment storage.

    Download a file indicated by ``path`` from the experiment artifacts and save it in ``destination_dir``.

    Args:
        path (:obj:`str`): Path to the file to be downloaded.
        destination_dir (:obj:`str`):
            The directory where the file will be downloaded.
            If ``None`` is passed, the file will be downloaded to the current working directory.

    Raises:
        `NotADirectory`: When ``destination_dir`` is not a directory.
        `FileNotFound`: If a path in experiment artifacts does not exist.

    Examples:
        Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`.

        .. code:: python3

            experiment.download_artifact(&#39;forest_results.pkl&#39;, &#39;/home/user/files/&#39;)
    &#34;&#34;&#34;
    if not destination_dir:
        destination_dir = os.getcwd()

    project_storage_path = &#34;/{exp_id}/output/{file}&#34;.format(exp_id=self.id, file=path)
    destination_path = os.path.join(destination_dir, os.path.basename(path))

    if not os.path.exists(destination_dir):
        os.makedirs(destination_dir)
    elif not os.path.isdir(destination_dir):
        raise NotADirectory(destination_dir)

    try:
        self._backend.download_data(self._project, project_storage_path, destination_path)
    except PathInProjectNotFound:
        raise FileNotFound(path)</code></pre>
</details>
</dd>
<dt id="neptune.experiments.Experiment.download_artifacts"><code class="name flex">
<span>def <span class="ident">download_artifacts</span></span>(<span>self, path=None, destination_dir=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Download a directory or a single file from experiment's artifacts as a ZIP archive.</p>
<p>Download a subdirectory (or file) <code>path</code> from the experiment artifacts and save it in <code>destination_dir</code>
as a ZIP archive. The name of an archive will be a name of downloaded directory (or file) with '.zip' extension.</p>
<h2 id="args">Args</h2>
<p>path (:obj:<code>str</code>):
Path of a directory or file in experiment artifacts to be downloaded.
If <code>None</code> is passed, all artifacts will be downloaded.</p>
<p>destination_dir (:obj:<code>str</code>): The directory where the archive will be downloaded.
If <code>None</code> is passed, the archive will be downloaded to the current working directory.</p>
<h2 id="raises">Raises</h2>
<p><code>NotADirectory</code>: When <code>destination_dir</code> is not a directory.
<code>FileNotFound</code>: If a path in experiment artifacts does not exist.</p>
<h2 id="examples">Examples</h2>
<p>Assuming that <code>experiment</code> is an instance of :class:<code>~neptune.experiments.Experiment</code>.</p>
<div class="admonition code">
<p class="admonition-title">Code:&ensp;python3</p>
<h1 id="download-all-experiment-artifacts-to-current-working-directory">Download all experiment artifacts to current working directory</h1>
<p>experiment.download_artifacts()</p>
<h1 id="download-a-single-directory">Download a single directory</h1>
<p>experiment.download_artifacts('data/images')</p>
<h1 id="download-all-experiment-artifacts-to-user-defined-directory">Download all experiment artifacts to user-defined directory</h1>
<p>experiment.download_artifacts(destination_dir='/tmp/artifacts/')</p>
<h1 id="download-a-single-directory-to-user-defined-directory">Download a single directory to user-defined directory</h1>
<p>experiment.download_artifacts('data/images', 'artifacts/')</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download_artifacts(self, path=None, destination_dir=None):
    &#34;&#34;&#34;Download a directory or a single file from experiment&#39;s artifacts as a ZIP archive.

    Download a subdirectory (or file) ``path`` from the experiment artifacts and save it in ``destination_dir``
    as a ZIP archive. The name of an archive will be a name of downloaded directory (or file) with &#39;.zip&#39; extension.

    Args:
        path (:obj:`str`):
            Path of a directory or file in experiment artifacts to be downloaded.
            If ``None`` is passed, all artifacts will be downloaded.

        destination_dir (:obj:`str`): The directory where the archive will be downloaded.
            If ``None`` is passed, the archive will be downloaded to the current working directory.

    Raises:
        `NotADirectory`: When ``destination_dir`` is not a directory.
        `FileNotFound`: If a path in experiment artifacts does not exist.

    Examples:
        Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`.

        .. code:: python3

            # Download all experiment artifacts to current working directory
            experiment.download_artifacts()

            # Download a single directory
            experiment.download_artifacts(&#39;data/images&#39;)

            # Download all experiment artifacts to user-defined directory
            experiment.download_artifacts(destination_dir=&#39;/tmp/artifacts/&#39;)

            # Download a single directory to user-defined directory
            experiment.download_artifacts(&#39;data/images&#39;, &#39;artifacts/&#39;)
    &#34;&#34;&#34;
    if not path:
        path = &#34;&#34;
    if not destination_dir:
        destination_dir = os.getcwd()

    if not os.path.exists(destination_dir):
        os.makedirs(destination_dir)
    elif not os.path.isdir(destination_dir):
        raise NotADirectory(destination_dir)

    download_request = self._backend.prepare_output_download_reuqest(self, path)
    self._download_from_request(download_request, destination_dir, path)</code></pre>
</details>
</dd>
<dt id="neptune.experiments.Experiment.download_sources"><code class="name flex">
<span>def <span class="ident">download_sources</span></span>(<span>self, path=None, destination_dir=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Download a directory or a single file from experiment's sources as a ZIP archive.</p>
<p>Download a subdirectory (or file) <code>path</code> from the experiment sources and save it in <code>destination_dir</code>
as a ZIP archive. The name of an archive will be a name of downloaded directory (or file) with '.zip' extension.</p>
<h2 id="args">Args</h2>
<p>path (:obj:<code>str</code>):
Path of a directory or file in experiment sources to be downloaded.
If <code>None</code> is passed, all source files will be downloaded.</p>
<p>destination_dir (:obj:<code>str</code>): The directory where the archive will be downloaded.
If <code>None</code> is passed, the archive will be downloaded to the current working directory.</p>
<h2 id="raises">Raises</h2>
<p><code>NotADirectory</code>: When <code>destination_dir</code> is not a directory.
<code>FileNotFound</code>: If a path in experiment sources does not exist.</p>
<h2 id="examples">Examples</h2>
<p>Assuming that <code>experiment</code> is an instance of :class:<code>~neptune.experiments.Experiment</code>.</p>
<div class="admonition code">
<p class="admonition-title">Code:&ensp;python3</p>
<h1 id="download-all-experiment-sources-to-current-working-directory">Download all experiment sources to current working directory</h1>
<p>experiment.download_sources()</p>
<h1 id="download-a-single-directory">Download a single directory</h1>
<p>experiment.download_sources('src/my-module')</p>
<h1 id="download-all-experiment-sources-to-user-defined-directory">Download all experiment sources to user-defined directory</h1>
<p>experiment.download_sources(destination_dir='/tmp/sources/')</p>
<h1 id="download-a-single-directory-to-user-defined-directory">Download a single directory to user-defined directory</h1>
<p>experiment.download_sources('src/my-module', 'sources/')</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download_sources(self, path=None, destination_dir=None):
    &#34;&#34;&#34;Download a directory or a single file from experiment&#39;s sources as a ZIP archive.

    Download a subdirectory (or file) ``path`` from the experiment sources and save it in ``destination_dir``
    as a ZIP archive. The name of an archive will be a name of downloaded directory (or file) with &#39;.zip&#39; extension.

    Args:
        path (:obj:`str`):
            Path of a directory or file in experiment sources to be downloaded.
            If ``None`` is passed, all source files will be downloaded.

        destination_dir (:obj:`str`): The directory where the archive will be downloaded.
            If ``None`` is passed, the archive will be downloaded to the current working directory.

    Raises:
        `NotADirectory`: When ``destination_dir`` is not a directory.
        `FileNotFound`: If a path in experiment sources does not exist.

    Examples:
        Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`.

        .. code:: python3

            # Download all experiment sources to current working directory
            experiment.download_sources()

            # Download a single directory
            experiment.download_sources(&#39;src/my-module&#39;)

            # Download all experiment sources to user-defined directory
            experiment.download_sources(destination_dir=&#39;/tmp/sources/&#39;)

            # Download a single directory to user-defined directory
            experiment.download_sources(&#39;src/my-module&#39;, &#39;sources/&#39;)
    &#34;&#34;&#34;
    if not path:
        path = &#34;&#34;
    if not destination_dir:
        destination_dir = os.getcwd()

    if not os.path.exists(destination_dir):
        os.makedirs(destination_dir)
    elif not os.path.isdir(destination_dir):
        raise NotADirectory(destination_dir)

    download_request = self._backend.prepare_source_download_reuqest(self, path)
    self._download_from_request(download_request, destination_dir, path)</code></pre>
</details>
</dd>
<dt id="neptune.experiments.Experiment.get_channels"><code class="name flex">
<span>def <span class="ident">get_channels</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for :meth:<code>~neptune.experiments.Experiment.get_logs</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_channels(self):
    &#34;&#34;&#34;Alias for :meth:`~neptune.experiments.Experiment.get_logs`
    &#34;&#34;&#34;
    return self.get_logs()</code></pre>
</details>
</dd>
<dt id="neptune.experiments.Experiment.get_hardware_utilization"><code class="name flex">
<span>def <span class="ident">get_hardware_utilization</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve GPU, CPU and memory utilization data.</p>
<p>Get hardware utilization metrics for entire experiment as a single
<code>pandas.DataFrame &lt;https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html&gt;</code>_
object. Returned DataFrame has following columns (assuming single GPU with 0 index):</p>
<pre><code>* &lt;code&gt;x\_ram&lt;/code&gt; - time (in milliseconds) from the experiment start,
* &lt;code&gt;y\_ram&lt;/code&gt; - memory usage in GB,
* &lt;code&gt;x\_cpu&lt;/code&gt; - time (in milliseconds) from the experiment start,
* &lt;code&gt;y\_cpu&lt;/code&gt; - CPU utilization percentage (0-100),
* &lt;code&gt;x\_gpu\_util\_0&lt;/code&gt; - time (in milliseconds) from the experiment start,
* &lt;code&gt;y\_gpu\_util\_0&lt;/code&gt; - GPU utilization percentage (0-100),
* &lt;code&gt;x\_gpu\_mem\_0&lt;/code&gt; - time (in milliseconds) from the experiment start,
* &lt;code&gt;y\_gpu\_mem\_0&lt;/code&gt; - GPU memory usage in GB.
</code></pre>
<p>| If more GPUs are available they have their separate columns with appropriate indices (0, 1, 2, &hellip;),
for example: <code>x_gpu_util_1</code>, <code>y_gpu_util_1</code>.
| The returned DataFrame may contain <code>NaN</code> s if one of the metrics has more values than others.</p>
<h2 id="returns">Returns</h2>
<p>:obj:<code>pandas.DataFrame</code> - DataFrame containing the hardware utilization metrics.</p>
<h2 id="examples">Examples</h2>
<p>The following values denote that after 3 seconds, the experiment used 16.7 GB of RAM</p>
<pre><code>* &lt;code&gt;x\_ram&lt;/code&gt; = 3000
* &lt;code&gt;y\_ram&lt;/code&gt; = 16.7
</code></pre>
<p>Assuming that <code>experiment</code> is an instance of :class:<code>~neptune.experiments.Experiment</code>:</p>
<div class="admonition code">
<p class="admonition-title">Code:&ensp;python3</p>
<p>hardware_df = experiment.get_hardware_utilization()</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_hardware_utilization(self):
    &#34;&#34;&#34;Retrieve GPU, CPU and memory utilization data.

    Get hardware utilization metrics for entire experiment as a single
    `pandas.DataFrame &lt;https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html&gt;`_
    object. Returned DataFrame has following columns (assuming single GPU with 0 index):

        * `x_ram` - time (in milliseconds) from the experiment start,
        * `y_ram` - memory usage in GB,
        * `x_cpu` - time (in milliseconds) from the experiment start,
        * `y_cpu` - CPU utilization percentage (0-100),
        * `x_gpu_util_0` - time (in milliseconds) from the experiment start,
        * `y_gpu_util_0` - GPU utilization percentage (0-100),
        * `x_gpu_mem_0` - time (in milliseconds) from the experiment start,
        * `y_gpu_mem_0` - GPU memory usage in GB.

    | If more GPUs are available they have their separate columns with appropriate indices (0, 1, 2, ...),
      for example: `x_gpu_util_1`, `y_gpu_util_1`.
    | The returned DataFrame may contain ``NaN`` s if one of the metrics has more values than others.

    Returns:
        :obj:`pandas.DataFrame` - DataFrame containing the hardware utilization metrics.

    Examples:
        The following values denote that after 3 seconds, the experiment used 16.7 GB of RAM

            * `x_ram` = 3000
            * `y_ram` = 16.7

        Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`:

        .. code:: python3

            hardware_df = experiment.get_hardware_utilization()
    &#34;&#34;&#34;
    metrics_csv = self._backend.get_metrics_csv(self)
    try:
        return pd.read_csv(metrics_csv)
    except EmptyDataError:
        return pd.DataFrame()</code></pre>
</details>
</dd>
<dt id="neptune.experiments.Experiment.get_logs"><code class="name flex">
<span>def <span class="ident">get_logs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve all log names along with their last values for this experiment.</p>
<h2 id="returns">Returns</h2>
<p>:obj:<code>dict</code> - A dictionary mapping a log names to the log's last value.</p>
<h2 id="example">Example</h2>
<p>Assuming that <code>experiment</code> is an instance of :class:<code>~neptune.experiments.Experiment</code>.</p>
<div class="admonition code">
<p class="admonition-title">Code:&ensp;python3</p>
<p>exp_logs = experiment.get_logs()</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_logs(self):
    &#34;&#34;&#34;Retrieve all log names along with their last values for this experiment.

    Returns:
        :obj:`dict` - A dictionary mapping a log names to the log&#39;s last value.

    Example:
        Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`.

        .. code:: python3

            exp_logs = experiment.get_logs()
    &#34;&#34;&#34;
    experiment = self._backend.get_experiment(self.internal_id)
    channels_last_values_by_name = dict((ch.channelName, ch) for ch in experiment.channelsLastValues)
    channels = dict()
    for ch in experiment.channels:
        last_value = channels_last_values_by_name.get(ch.name, None)
        if last_value is not None:
            ch.x = last_value.x
            ch.y = last_value.y
        elif ch.lastX is not None:
            ch.x = ch.lastX
            ch.y = None
        else:
            ch.x = None
            ch.y = None
        channels[ch.name] = ch
    return channels</code></pre>
</details>
</dd>
<dt id="neptune.experiments.Experiment.get_numeric_channels_values"><code class="name flex">
<span>def <span class="ident">get_numeric_channels_values</span></span>(<span>self, *channel_names)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve values of specified metrics (numeric logs).</p>
<p>The returned
<code>pandas.DataFrame &lt;https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html&gt;</code>_
contains 1 additional column <code>x</code> along with the requested metrics.</p>
<h2 id="args">Args</h2>
<p>*channel_names (one or more :obj:<code>str</code>): comma-separated metric names.</p>
<h2 id="returns">Returns</h2>
<p>:obj:<code>pandas.DataFrame</code> - DataFrame containing values for the requested metrics.</p>
<p>| The returned DataFrame may contain <code>NaN</code> s if one of the metrics has more values than others.</p>
<h2 id="example">Example</h2>
<p>Invoking <code>get_numeric_channels_values('loss', 'auc')</code> returns DataFrame with columns
<code>x</code>, <code>loss</code>, <code>auc</code>.</p>
<p>Assuming that <code>experiment</code> is an instance of :class:<code>~neptune.experiments.Experiment</code>:</p>
<div class="admonition code">
<p class="admonition-title">Code:&ensp;python3</p>
<p>batch_channels = experiment.get_numeric_channels_values('batch-1-loss', 'batch-2-metric')
epoch_channels = experiment.get_numeric_channels_values('epoch-1-loss', 'epoch-2-metric')</p>
</div>
<h2 id="note">Note</h2>
<p>It's good idea to get metrics with common temporal pattern (like iteration or batch/epoch number).
Thanks to this each row of returned DataFrame has metrics from the same moment in experiment.
For example, combine epoch metrics to one DataFrame and batch metrics to the other.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_numeric_channels_values(self, *channel_names):
    &#34;&#34;&#34;Retrieve values of specified metrics (numeric logs).

    The returned
    `pandas.DataFrame &lt;https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html&gt;`_
    contains 1 additional column `x` along with the requested metrics.

    Args:
        *channel_names (one or more :obj:`str`): comma-separated metric names.

    Returns:
        :obj:`pandas.DataFrame` - DataFrame containing values for the requested metrics.

        | The returned DataFrame may contain ``NaN`` s if one of the metrics has more values than others.

    Example:
        Invoking ``get_numeric_channels_values(&#39;loss&#39;, &#39;auc&#39;)`` returns DataFrame with columns
        `x`, `loss`, `auc`.

        Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`:

        .. code:: python3

            batch_channels = experiment.get_numeric_channels_values(&#39;batch-1-loss&#39;, &#39;batch-2-metric&#39;)
            epoch_channels = experiment.get_numeric_channels_values(&#39;epoch-1-loss&#39;, &#39;epoch-2-metric&#39;)

    Note:
        It&#39;s good idea to get metrics with common temporal pattern (like iteration or batch/epoch number).
        Thanks to this each row of returned DataFrame has metrics from the same moment in experiment.
        For example, combine epoch metrics to one DataFrame and batch metrics to the other.
    &#34;&#34;&#34;

    channels_data = {}
    channels_by_name = self.get_channels()
    for channel_name in channel_names:
        channel_id = channels_by_name[channel_name].id
        try:
            channels_data[channel_name] = pd.read_csv(
                self._backend.get_channel_points_csv(self, channel_id),
                header=None,
                names=[&#39;x_{}&#39;.format(channel_name), &#39;y_{}&#39;.format(channel_name)],
                dtype=float
            )
        except EmptyDataError:
            channels_data[channel_name] = pd.DataFrame(
                columns=[&#39;x_{}&#39;.format(channel_name), &#39;y_{}&#39;.format(channel_name)],
                dtype=float
            )

    return align_channels_on_x(pd.concat(channels_data.values(), axis=1, sort=False))</code></pre>
</details>
</dd>
<dt id="neptune.experiments.Experiment.get_parameters"><code class="name flex">
<span>def <span class="ident">get_parameters</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve parameters for this experiment.</p>
<h2 id="returns">Returns</h2>
<p>:obj:<code>dict</code> - dictionary mapping a parameter name to value.</p>
<h2 id="examples">Examples</h2>
<p>Assuming that <code>experiment</code> is an instance of :class:<code>~neptune.experiments.Experiment</code>.</p>
<div class="admonition code">
<p class="admonition-title">Code:&ensp;python3</p>
<p>exp_params = experiment.get_parameters()</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_parameters(self):
    &#34;&#34;&#34;Retrieve parameters for this experiment.

    Returns:
        :obj:`dict` - dictionary mapping a parameter name to value.

    Examples:
        Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`.

        .. code:: python3

            exp_params = experiment.get_parameters()
    &#34;&#34;&#34;
    experiment = self._backend.get_experiment(self.internal_id)
    return dict((p.name, self._convert_parameter_value(p.value, p.parameterType)) for p in experiment.parameters)</code></pre>
</details>
</dd>
<dt id="neptune.experiments.Experiment.get_properties"><code class="name flex">
<span>def <span class="ident">get_properties</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve User-defined properties for this experiment.</p>
<h2 id="returns">Returns</h2>
<p>:obj:<code>dict</code> - dictionary mapping a property key to value.</p>
<h2 id="examples">Examples</h2>
<p>Assuming that <code>experiment</code> is an instance of :class:<code>~neptune.experiments.Experiment</code>.</p>
<div class="admonition code">
<p class="admonition-title">Code:&ensp;python3</p>
<p>exp_properties = experiment.get_properties()</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_properties(self):
    &#34;&#34;&#34;Retrieve User-defined properties for this experiment.

    Returns:
        :obj:`dict` - dictionary mapping a property key to value.

    Examples:
        Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`.

        .. code:: python3

            exp_properties = experiment.get_properties()
    &#34;&#34;&#34;
    experiment = self._backend.get_experiment(self.internal_id)
    return dict((p.key, p.value) for p in experiment.properties)</code></pre>
</details>
</dd>
<dt id="neptune.experiments.Experiment.get_system_properties"><code class="name flex">
<span>def <span class="ident">get_system_properties</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve experiment properties.</p>
<p>| Experiment properties are for example: <code>owner</code>, <code>created</code>, <code>name</code>, <code>hostname</code>.
| List of experiment properties may change over time.</p>
<h2 id="returns">Returns</h2>
<p>:obj:<code>dict</code> - dictionary mapping a property name to value.</p>
<h2 id="examples">Examples</h2>
<p>Assuming that <code>experiment</code> is an instance of :class:<code>~neptune.experiments.Experiment</code>.</p>
<div class="admonition code">
<p class="admonition-title">Code:&ensp;python3</p>
<p>sys_properties = experiment.get_system_properties</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_system_properties(self):
    &#34;&#34;&#34;Retrieve experiment properties.

    | Experiment properties are for example: `owner`, `created`, `name`, `hostname`.
    | List of experiment properties may change over time.

    Returns:
        :obj:`dict` - dictionary mapping a property name to value.

    Examples:
        Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`.

        .. code:: python3

            sys_properties = experiment.get_system_properties
    &#34;&#34;&#34;
    experiment = self._backend.get_experiment(self._internal_id)
    return {
        &#39;id&#39;: experiment.shortId,
        &#39;name&#39;: experiment.name,
        &#39;created&#39;: experiment.timeOfCreation,
        &#39;finished&#39;: experiment.timeOfCompletion,
        &#39;running_time&#39;: experiment.runningTime,
        &#39;owner&#39;: experiment.owner,
        &#39;storage_size&#39;: experiment.storageSize,
        &#39;channels_size&#39;: experiment.channelsSize,
        &#39;size&#39;: experiment.storageSize + experiment.channelsSize,
        &#39;tags&#39;: experiment.tags,
        &#39;notes&#39;: experiment.description,
        &#39;description&#39;: experiment.description,
        &#39;hostname&#39;: experiment.hostname
    }</code></pre>
</details>
</dd>
<dt id="neptune.experiments.Experiment.get_tags"><code class="name flex">
<span>def <span class="ident">get_tags</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get tags associated with experiment.</p>
<h2 id="returns">Returns</h2>
<p>:obj:<code>list</code> of :obj:<code>str</code> with all tags for this experiment.</p>
<h2 id="example">Example</h2>
<p>Assuming that <code>experiment</code> is an instance of :class:<code>~neptune.experiments.Experiment</code>.</p>
<div class="admonition code">
<p class="admonition-title">Code:&ensp;python3</p>
<p>experiment.get_tags()</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_tags(self):
    &#34;&#34;&#34;Get tags associated with experiment.

    Returns:
        :obj:`list` of :obj:`str` with all tags for this experiment.

    Example:
        Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`.

        .. code:: python3

            experiment.get_tags()
    &#34;&#34;&#34;
    return self._backend.get_experiment(self._internal_id).tags</code></pre>
</details>
</dd>
<dt id="neptune.experiments.Experiment.log_artifact"><code class="name flex">
<span>def <span class="ident">log_artifact</span></span>(<span>self, artifact, destination=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Save an artifact (file) in experiment storage.</p>
<h2 id="args">Args</h2>
<p>artifact (:obj:<code>str</code> or :obj:<code>IO object</code>):
A path to the file in local filesystem or IO object. It can be open
file descriptor or in-memory buffer like <code>io.StringIO</code> or <code>io.BytesIO</code>.
destination (:obj:<code>str</code>, optional, default is <code>None</code>):
A destination path.
If <code>None</code> is passed, an artifact file name will be used.</p>
<h2 id="raises">Raises</h2>
<p><code>FileNotFound</code>: When <code>artifact</code> file was not found.
<code>StorageLimitReached</code>: When storage limit in the project has been reached.</p>
<h2 id="example">Example</h2>
<p>Assuming that <code>experiment</code> is an instance of :class:<code>~neptune.experiments.Experiment</code>:</p>
<div class="admonition code">
<p class="admonition-title">Code:&ensp;python3</p>
<h1 id="simple-use">simple use</h1>
<p>experiment.log_artifact('images/wrong_prediction_1.png')</p>
<h1 id="save-file-in-other-directory">save file in other directory</h1>
<p>experiment.log_artifact('images/wrong_prediction_1.png', 'validation/images/wrong_prediction_1.png')</p>
<h1 id="save-file-under-different-name">save file under different name</h1>
<p>experiment.log_artifact('images/wrong_prediction_1.png', 'images/my_image_1.png')</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log_artifact(self, artifact, destination=None):
    &#34;&#34;&#34;Save an artifact (file) in experiment storage.

    Args:
        artifact (:obj:`str` or :obj:`IO object`):
            A path to the file in local filesystem or IO object. It can be open
            file descriptor or in-memory buffer like `io.StringIO` or `io.BytesIO`.
        destination (:obj:`str`, optional, default is ``None``):
            A destination path.
            If ``None`` is passed, an artifact file name will be used.

    Raises:
        `FileNotFound`: When ``artifact`` file was not found.
        `StorageLimitReached`: When storage limit in the project has been reached.

    Example:
        Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`:

        .. code:: python3

            # simple use
            experiment.log_artifact(&#39;images/wrong_prediction_1.png&#39;)

            # save file in other directory
            experiment.log_artifact(&#39;images/wrong_prediction_1.png&#39;, &#39;validation/images/wrong_prediction_1.png&#39;)

            # save file under different name
            experiment.log_artifact(&#39;images/wrong_prediction_1.png&#39;, &#39;images/my_image_1.png&#39;)
    &#34;&#34;&#34;
    if isinstance(artifact, str):
        if os.path.exists(artifact):
            target_name = os.path.basename(artifact) if destination is None else destination
            upload_entry = UploadEntry(os.path.abspath(artifact), normalize_file_name(target_name))
        else:
            raise FileNotFound(artifact)
    elif hasattr(artifact, &#39;read&#39;):
        if destination is not None:
            upload_entry = UploadEntry(artifact, normalize_file_name(destination))
        else:
            raise ValueError(&#34;destination is required for file streams&#34;)
    else:
        raise ValueError(&#34;artifact is a local path or an IO object&#34;)

    upload_to_storage(upload_entries=[upload_entry],
                      upload_api_fun=self._backend.upload_experiment_output,
                      upload_tar_api_fun=self._backend.extract_experiment_output,
                      experiment=self)</code></pre>
</details>
</dd>
<dt id="neptune.experiments.Experiment.log_image"><code class="name flex">
<span>def <span class="ident">log_image</span></span>(<span>self, log_name, x, y=None, image_name=None, description=None, timestamp=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Log image data in Neptune</p>
<p>| If a log with provided <code>log_name</code> does not exist, it is created automatically.
| If log exists (determined by <code>log_name</code>), then new value is appended to it.</p>
<h2 id="args">Args</h2>
<p>log_name (:obj:<code>str</code>): The name of log, i.e. <code>bboxes</code>, <code>visualisations</code>, <code>sample_images</code>.
x (:obj:<code>double</code>): Depending, whether <code>y</code> parameter is passed:</p>
<pre><code>* &lt;code&gt;y&lt;/code&gt; not passed: The value of the log (data-point). See &lt;code&gt;y&lt;/code&gt; parameter.
* &lt;code&gt;y&lt;/code&gt; passed: Index of log entry being appended. Must be strictly increasing.
</code></pre>
<p>y (multiple types supported, optional, default is <code>None</code>):</p>
<pre><code>The value of the log (data-point). Can be one of the following types:

* :obj:&lt;code&gt;PIL image&lt;/code&gt;
  `Pillow docs &lt;https://pillow.readthedocs.io/en/latest/reference/Image.html#image-module&gt;`_
* :obj:&lt;code&gt;matplotlib.figure.Figure&lt;/code&gt;
  `Matplotlib 3.1.1 docs &lt;https://matplotlib.org/3.1.1/api/_as_gen/matplotlib.figure.Figure.html&gt;`_
* :obj:&lt;code&gt;str&lt;/code&gt; - path to image file
* 2-dimensional :obj:&lt;code&gt;numpy.array&lt;/code&gt; - interpreted as grayscale image
* 3-dimensional :obj:&lt;code&gt;numpy.array&lt;/code&gt; - behavior depends on last dimension

    * if last dimension is 1 - interpreted as grayscale image
    * if last dimension is 3 - interpreted as RGB image
    * if last dimension is 4 - interpreted as RGBA image
</code></pre>
<p>image_name (:obj:<code>str</code>, optional, default is <code>None</code>): Image name
description (:obj:<code>str</code>, optional, default is <code>None</code>): Image description
timestamp (:obj:<code>time</code>, optional, default is <code>None</code>):
Timestamp to be associated with log entry. Must be Unix time.
If <code>None</code> is passed, <code>time.time() &lt;https://docs.python.org/3.6/library/time.html#time.time&gt;</code>_
(Python 3.6 example) is invoked to obtain timestamp.</p>
<h2 id="example">Example</h2>
<p>Assuming that <code>experiment</code> is an instance of :class:<code>~neptune.experiments.Experiment</code>:</p>
<div class="admonition code">
<p class="admonition-title">Code:&ensp;python3</p>
<h1 id="path-to-image-file">path to image file</h1>
<p>experiment.log_image('bbox_images', 'pictures/image.png')
experiment.log_image('bbox_images', x=5, 'pictures/image.png')
experiment.log_image('bbox_images', 'pictures/image.png', image_name='difficult_case')</p>
<h1 id="pil-image">PIL image</h1>
<p>img = PIL.Image.new('RGB', (60, 30), color = 'red')
experiment.log_image('fig', img)</p>
<h1 id="2d-numpy-array">2d numpy array</h1>
<p>array = numpy.random.rand(300, 200)*255
experiment.log_image('fig', array)</p>
<h1 id="3d-grayscale-array">3d grayscale array</h1>
<p>array = numpy.random.rand(300, 200, 1)*255
experiment.log_image('fig', array)</p>
<h1 id="3d-rgb-array">3d RGB array</h1>
<p>array = numpy.random.rand(300, 200, 3)*255
experiment.log_image('fig', array)</p>
<h1 id="3d-rgba-array">3d RGBA array</h1>
<p>array = numpy.random.rand(300, 200, 4)*255
experiment.log_image('fig', array)</p>
<h1 id="matplotlib-figure-example-1">matplotlib figure example 1</h1>
<p>from matplotlib import pyplot
pyplot.plot([1, 2, 3, 4])
pyplot.ylabel('some numbers')
experiment.log_image('plots', plt.gcf())</p>
<h1 id="matplotlib-figure-example-2">matplotlib figure example 2</h1>
<p>from matplotlib import pyplot
import numpy</p>
<p>numpy.random.seed(19680801)
data = numpy.random.randn(2, 100)</p>
<p>figure, axs = pyplot.subplots(2, 2, figsize=(5, 5))
axs[0, 0].hist(data[0])
axs[1, 0].scatter(data[0], data[1])
axs[0, 1].plot(data[0], data[1])
axs[1, 1].hist2d(data[0], data[1])</p>
<p>experiment.log_image('diagrams', figure)</p>
</div>
<h2 id="note">Note</h2>
<p>For efficiency, logs are uploaded in batches via a queue.
Hence, if you log a lot of data, you may experience slight delays in Neptune web application.</p>
<h2 id="note_1">Note</h2>
<p>Passing <code>x</code> coordinate as NaN or +/-inf causes this log entry to be ignored.
Warning is printed to <code>stdout</code>.</p>
<h2 id="warning">Warning</h2>
<p>Only images up to 15MB are supported. Larger files will not be logged to Neptune.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log_image(self, log_name, x, y=None, image_name=None, description=None, timestamp=None):
    &#34;&#34;&#34;Log image data in Neptune

    | If a log with provided ``log_name`` does not exist, it is created automatically.
    | If log exists (determined by ``log_name``), then new value is appended to it.

    Args:
        log_name (:obj:`str`): The name of log, i.e. `bboxes`, `visualisations`, `sample_images`.
        x (:obj:`double`): Depending, whether ``y`` parameter is passed:

            * ``y`` not passed: The value of the log (data-point). See ``y`` parameter.
            * ``y`` passed: Index of log entry being appended. Must be strictly increasing.

        y (multiple types supported, optional, default is ``None``):

            The value of the log (data-point). Can be one of the following types:

            * :obj:`PIL image`
              `Pillow docs &lt;https://pillow.readthedocs.io/en/latest/reference/Image.html#image-module&gt;`_
            * :obj:`matplotlib.figure.Figure`
              `Matplotlib 3.1.1 docs &lt;https://matplotlib.org/3.1.1/api/_as_gen/matplotlib.figure.Figure.html&gt;`_
            * :obj:`str` - path to image file
            * 2-dimensional :obj:`numpy.array` - interpreted as grayscale image
            * 3-dimensional :obj:`numpy.array` - behavior depends on last dimension

                * if last dimension is 1 - interpreted as grayscale image
                * if last dimension is 3 - interpreted as RGB image
                * if last dimension is 4 - interpreted as RGBA image

        image_name (:obj:`str`, optional, default is ``None``): Image name
        description (:obj:`str`, optional, default is ``None``): Image description
        timestamp (:obj:`time`, optional, default is ``None``):
            Timestamp to be associated with log entry. Must be Unix time.
            If ``None`` is passed, `time.time() &lt;https://docs.python.org/3.6/library/time.html#time.time&gt;`_
            (Python 3.6 example) is invoked to obtain timestamp.

    Example:
        Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`:

        .. code:: python3

            # path to image file
            experiment.log_image(&#39;bbox_images&#39;, &#39;pictures/image.png&#39;)
            experiment.log_image(&#39;bbox_images&#39;, x=5, &#39;pictures/image.png&#39;)
            experiment.log_image(&#39;bbox_images&#39;, &#39;pictures/image.png&#39;, image_name=&#39;difficult_case&#39;)

            # PIL image
            img = PIL.Image.new(&#39;RGB&#39;, (60, 30), color = &#39;red&#39;)
            experiment.log_image(&#39;fig&#39;, img)

            # 2d numpy array
            array = numpy.random.rand(300, 200)*255
            experiment.log_image(&#39;fig&#39;, array)

            # 3d grayscale array
            array = numpy.random.rand(300, 200, 1)*255
            experiment.log_image(&#39;fig&#39;, array)

            # 3d RGB array
            array = numpy.random.rand(300, 200, 3)*255
            experiment.log_image(&#39;fig&#39;, array)

            # 3d RGBA array
            array = numpy.random.rand(300, 200, 4)*255
            experiment.log_image(&#39;fig&#39;, array)

            # matplotlib figure example 1
            from matplotlib import pyplot
            pyplot.plot([1, 2, 3, 4])
            pyplot.ylabel(&#39;some numbers&#39;)
            experiment.log_image(&#39;plots&#39;, plt.gcf())

            # matplotlib figure example 2
            from matplotlib import pyplot
            import numpy

            numpy.random.seed(19680801)
            data = numpy.random.randn(2, 100)

            figure, axs = pyplot.subplots(2, 2, figsize=(5, 5))
            axs[0, 0].hist(data[0])
            axs[1, 0].scatter(data[0], data[1])
            axs[0, 1].plot(data[0], data[1])
            axs[1, 1].hist2d(data[0], data[1])

            experiment.log_image(&#39;diagrams&#39;, figure)

    Note:
        For efficiency, logs are uploaded in batches via a queue.
        Hence, if you log a lot of data, you may experience slight delays in Neptune web application.
    Note:
        Passing ``x`` coordinate as NaN or +/-inf causes this log entry to be ignored.
        Warning is printed to ``stdout``.
    Warning:
        Only images up to 15MB are supported. Larger files will not be logged to Neptune.
    &#34;&#34;&#34;
    x, y = self._get_valid_x_y(x, y)

    if x is not None and is_nan_or_inf(x):
        x = None

    image_content = get_image_content(y)
    if len(image_content) &gt; self.IMAGE_SIZE_LIMIT_MB * 1024 * 1024:
        _logger.warning(&#39;Your image is larger than %dMB. Neptune supports logging images smaller than %dMB. &#39;
                        &#39;Resize or increase compression of this image&#39;,
                        self.IMAGE_SIZE_LIMIT_MB,
                        self.IMAGE_SIZE_LIMIT_MB)
        image_content = None

    input_image = dict(
        name=image_name,
        description=description
    )
    if image_content:
        input_image[&#39;data&#39;] = base64.b64encode(image_content).decode(&#39;utf-8&#39;)

    if x is not None and is_nan_or_inf(x):
        _logger.warning(
            &#39;Invalid metric x-coordinate: %s for channel %s. &#39;
            &#39;Metrics with nan or +/-inf x-coordinates will not be sent to server&#39;,
            x,
            log_name)
    else:
        value = ChannelValue(x, dict(image_value=input_image), timestamp)
        self._channels_values_sender.send(log_name, ChannelType.IMAGE.value, value)</code></pre>
</details>
</dd>
<dt id="neptune.experiments.Experiment.log_metric"><code class="name flex">
<span>def <span class="ident">log_metric</span></span>(<span>self, log_name, x, y=None, timestamp=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Log metrics (numeric values) in Neptune</p>
<p>| If a log with provided <code>log_name</code> does not exist, it is created automatically.
| If log exists (determined by <code>log_name</code>), then new value is appended to it.</p>
<h2 id="args">Args</h2>
<p>log_name (:obj:<code>str</code>): The name of log, i.e. <code>mse</code>, <code>loss</code>, <code>accuracy</code>.
x (:obj:<code>double</code>): Depending, whether <code>y</code> parameter is passed:</p>
<pre><code>* &lt;code&gt;y&lt;/code&gt; not passed: The value of the log (data-point).
* &lt;code&gt;y&lt;/code&gt; passed: Index of log entry being appended. Must be strictly increasing.
</code></pre>
<p>y (:obj:<code>double</code>, optional, default is <code>None</code>): The value of the log (data-point).
timestamp (:obj:<code>time</code>, optional, default is <code>None</code>):
Timestamp to be associated with log entry. Must be Unix time.
If <code>None</code> is passed, <code>time.time() &lt;https://docs.python.org/3.6/library/time.html#time.time&gt;</code>_
(Python 3.6 example) is invoked to obtain timestamp.</p>
<h2 id="example">Example</h2>
<p>Assuming that <code>experiment</code> is an instance of :class:<code>~neptune.experiments.Experiment</code> and
'accuracy' log does not exists:</p>
<div class="admonition code">
<p class="admonition-title">Code:&ensp;python3</p>
<h1 id="both-calls-below-have-the-same-effect">Both calls below have the same effect</h1>
<h1 id="common-invocation-providing-log-name-and-value">Common invocation, providing log name and value</h1>
<p>experiment.log_metric('accuracy', 0.5)
experiment.log_metric('accuracy', 0.65)
experiment.log_metric('accuracy', 0.8)</p>
<h1 id="providing-both-x-and-y-params">Providing both x and y params</h1>
<p>experiment.log_metric('accuracy', 0, 0.5)
experiment.log_metric('accuracy', 1, 0.65)
experiment.log_metric('accuracy', 2, 0.8)</p>
</div>
<h2 id="note">Note</h2>
<p>For efficiency, logs are uploaded in batches via a queue.
Hence, if you log a lot of data, you may experience slight delays in Neptune web application.</p>
<h2 id="note_1">Note</h2>
<p>Passing either <code>x</code> or <code>y</code> coordinate as NaN or +/-inf causes this log entry to be ignored.
Warning is printed to <code>stdout</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log_metric(self, log_name, x, y=None, timestamp=None):
    &#34;&#34;&#34;Log metrics (numeric values) in Neptune

    | If a log with provided ``log_name`` does not exist, it is created automatically.
    | If log exists (determined by ``log_name``), then new value is appended to it.

    Args:
        log_name (:obj:`str`): The name of log, i.e. `mse`, `loss`, `accuracy`.
        x (:obj:`double`): Depending, whether ``y`` parameter is passed:

            * ``y`` not passed: The value of the log (data-point).
            * ``y`` passed: Index of log entry being appended. Must be strictly increasing.

        y (:obj:`double`, optional, default is ``None``): The value of the log (data-point).
        timestamp (:obj:`time`, optional, default is ``None``):
            Timestamp to be associated with log entry. Must be Unix time.
            If ``None`` is passed, `time.time() &lt;https://docs.python.org/3.6/library/time.html#time.time&gt;`_
            (Python 3.6 example) is invoked to obtain timestamp.

    Example:
        Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment` and
        &#39;accuracy&#39; log does not exists:

        .. code:: python3

            # Both calls below have the same effect

            # Common invocation, providing log name and value
            experiment.log_metric(&#39;accuracy&#39;, 0.5)
            experiment.log_metric(&#39;accuracy&#39;, 0.65)
            experiment.log_metric(&#39;accuracy&#39;, 0.8)

            # Providing both x and y params
            experiment.log_metric(&#39;accuracy&#39;, 0, 0.5)
            experiment.log_metric(&#39;accuracy&#39;, 1, 0.65)
            experiment.log_metric(&#39;accuracy&#39;, 2, 0.8)

    Note:
        For efficiency, logs are uploaded in batches via a queue.
        Hence, if you log a lot of data, you may experience slight delays in Neptune web application.
    Note:
        Passing either ``x`` or ``y`` coordinate as NaN or +/-inf causes this log entry to be ignored.
        Warning is printed to ``stdout``.
    &#34;&#34;&#34;
    x, y = self._get_valid_x_y(x, y)

    if not is_float(y):
        raise InvalidChannelValue(expected_type=&#39;float&#39;, actual_type=type(y).__name__)

    if is_nan_or_inf(y):
        _logger.warning(
            &#39;Invalid metric value: %s for channel %s. &#39;
            &#39;Metrics with nan or +/-inf values will not be sent to server&#39;,
            y,
            log_name)
    elif x is not None and is_nan_or_inf(x):
        _logger.warning(
            &#39;Invalid metric x-coordinate: %s for channel %s. &#39;
            &#39;Metrics with nan or +/-inf x-coordinates will not be sent to server&#39;,
            x,
            log_name)
    else:
        value = ChannelValue(x, dict(numeric_value=y), timestamp)
        self._channels_values_sender.send(log_name, ChannelType.NUMERIC.value, value)</code></pre>
</details>
</dd>
<dt id="neptune.experiments.Experiment.log_text"><code class="name flex">
<span>def <span class="ident">log_text</span></span>(<span>self, log_name, x, y=None, timestamp=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Log text data in Neptune</p>
<p>| If a log with provided <code>log_name</code> does not exist, it is created automatically.
| If log exists (determined by <code>log_name</code>), then new value is appended to it.</p>
<h2 id="args">Args</h2>
<p>log_name (:obj:<code>str</code>): The name of log, i.e. <code>mse</code>, <code>my_text_data</code>, <code>timing_info</code>.
x (:obj:<code>double</code> or :obj:<code>str</code>): Depending, whether <code>y</code> parameter is passed:</p>
<pre><code>* &lt;code&gt;y&lt;/code&gt; not passed: The value of the log (data-point). Must be &lt;code&gt;str&lt;/code&gt;.
* &lt;code&gt;y&lt;/code&gt; passed: Index of log entry being appended. Must be strictly increasing.
</code></pre>
<p>y (:obj:<code>str</code>, optional, default is <code>None</code>): The value of the log (data-point).
timestamp (:obj:<code>time</code>, optional, default is <code>None</code>):
Timestamp to be associated with log entry. Must be Unix time.
If <code>None</code> is passed, <code>time.time() &lt;https://docs.python.org/3.6/library/time.html#time.time&gt;</code>_
(Python 3.6 example) is invoked to obtain timestamp.</p>
<h2 id="example">Example</h2>
<p>Assuming that <code>experiment</code> is an instance of :class:<code>~neptune.experiments.Experiment</code>:</p>
<div class="admonition code">
<p class="admonition-title">Code:&ensp;python3</p>
<h1 id="common-case-where-log-name-and-data-are-passed">common case, where log name and data are passed</h1>
<p>neptune.log_text('my_text_data', str(data_item))</p>
<h1 id="log_name-x-and-timestamp-are-passed">log_name, x and timestamp are passed</h1>
<p>neptune.log_text(log_name='logging_losses_as_text',
x=str(val_loss),
timestamp=1560430912)</p>
</div>
<h2 id="note">Note</h2>
<p>For efficiency, logs are uploaded in batches via a queue.
Hence, if you log a lot of data, you may experience slight delays in Neptune web application.</p>
<h2 id="note_1">Note</h2>
<p>Passing <code>x</code> coordinate as NaN or +/-inf causes this log entry to be ignored.
Warning is printed to <code>stdout</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log_text(self, log_name, x, y=None, timestamp=None):
    &#34;&#34;&#34;Log text data in Neptune

    | If a log with provided ``log_name`` does not exist, it is created automatically.
    | If log exists (determined by ``log_name``), then new value is appended to it.

    Args:
        log_name (:obj:`str`): The name of log, i.e. `mse`, `my_text_data`, `timing_info`.
        x (:obj:`double` or :obj:`str`): Depending, whether ``y`` parameter is passed:

            * ``y`` not passed: The value of the log (data-point). Must be ``str``.
            * ``y`` passed: Index of log entry being appended. Must be strictly increasing.

        y (:obj:`str`, optional, default is ``None``): The value of the log (data-point).
        timestamp (:obj:`time`, optional, default is ``None``):
            Timestamp to be associated with log entry. Must be Unix time.
            If ``None`` is passed, `time.time() &lt;https://docs.python.org/3.6/library/time.html#time.time&gt;`_
            (Python 3.6 example) is invoked to obtain timestamp.

    Example:
        Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`:

        .. code:: python3

            # common case, where log name and data are passed
            neptune.log_text(&#39;my_text_data&#39;, str(data_item))

            # log_name, x and timestamp are passed
            neptune.log_text(log_name=&#39;logging_losses_as_text&#39;,
                             x=str(val_loss),
                             timestamp=1560430912)

    Note:
        For efficiency, logs are uploaded in batches via a queue.
        Hence, if you log a lot of data, you may experience slight delays in Neptune web application.
    Note:
        Passing ``x`` coordinate as NaN or +/-inf causes this log entry to be ignored.
        Warning is printed to ``stdout``.
    &#34;&#34;&#34;
    x, y = self._get_valid_x_y(x, y)

    if x is not None and is_nan_or_inf(x):
        x = None

    if not isinstance(y, six.string_types):
        raise InvalidChannelValue(expected_type=&#39;str&#39;, actual_type=type(y).__name__)

    if x is not None and is_nan_or_inf(x):
        _logger.warning(
            &#39;Invalid metric x-coordinate: %s for channel %s. &#39;
            &#39;Metrics with nan or +/-inf x-coordinates will not be sent to server&#39;,
            x,
            log_name)
    else:
        value = ChannelValue(x, dict(text_value=y), timestamp)
        self._channels_values_sender.send(log_name, ChannelType.TEXT.value, value)</code></pre>
</details>
</dd>
<dt id="neptune.experiments.Experiment.remove_property"><code class="name flex">
<span>def <span class="ident">remove_property</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes a property with given key.</p>
<h2 id="args">Args</h2>
<p>key (single :obj:<code>str</code>):
Key of property to remove.</p>
<h2 id="examples">Examples</h2>
<p>Assuming that <code>experiment</code> is an instance of :class:<code>~neptune.experiments.Experiment</code>:</p>
<div class="admonition code">
<p class="admonition-title">Code:&ensp;python3</p>
<p>experiment.remove_property('host')</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_property(self, key):
    &#34;&#34;&#34;Removes a property with given key.

    Args:
        key (single :obj:`str`):
            Key of property to remove.

    Examples:
        Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`:

        .. code:: python3

            experiment.remove_property(&#39;host&#39;)
    &#34;&#34;&#34;
    properties = {p.key: p.value for p in self._backend.get_experiment(self.internal_id).properties}
    del properties[key]
    return self._backend.update_experiment(
        experiment=self,
        properties=properties
    )</code></pre>
</details>
</dd>
<dt id="neptune.experiments.Experiment.remove_tag"><code class="name flex">
<span>def <span class="ident">remove_tag</span></span>(<span>self, tag)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes single tag from the experiment.</p>
<h2 id="args">Args</h2>
<p>tag (:obj:<code>str</code>): Tag to be removed</p>
<h2 id="example">Example</h2>
<p>Assuming that <code>experiment</code> is an instance of :class:<code>~neptune.experiments.Experiment</code>.</p>
<div class="admonition code">
<p class="admonition-title">Code:&ensp;python3</p>
<h1 id="assuming-experiment-has-tags-tag-1-tag-2">assuming experiment has tags: <code>['tag-1', 'tag-2']</code>.</h1>
<p>experiment.remove_tag('tag-1')</p>
</div>
<h2 id="note">Note</h2>
<p>Removing a tag that is not assigned to this experiment is silently ignored.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_tag(self, tag):
    &#34;&#34;&#34;Removes single tag from the experiment.

    Args:
        tag (:obj:`str`): Tag to be removed

    Example:
        Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`.

        .. code:: python3

            # assuming experiment has tags: `[&#39;tag-1&#39;, &#39;tag-2&#39;]`.
            experiment.remove_tag(&#39;tag-1&#39;)

    Note:
        Removing a tag that is not assigned to this experiment is silently ignored.
    &#34;&#34;&#34;
    self._backend.update_tags(experiment=self,
                              tags_to_add=[],
                              tags_to_delete=[tag])</code></pre>
</details>
</dd>
<dt id="neptune.experiments.Experiment.reset_log"><code class="name flex">
<span>def <span class="ident">reset_log</span></span>(<span>self, log_name)</span>
</code></dt>
<dd>
<div class="desc"><p>Resets the log.</p>
<p>Removes all data from the log and enables it to be reused from scratch.</p>
<h2 id="args">Args</h2>
<p>log_name (:obj:<code>str</code>): The name of log to reset.</p>
<h2 id="raises">Raises</h2>
<p><code>ChannelDoesNotExist</code>: When the log with name <code>log_name</code> does not exist on the server.</p>
<h2 id="example">Example</h2>
<p>Assuming that <code>experiment</code> is an instance of :class:<code>~neptune.experiments.Experiment</code>.</p>
<div class="admonition code">
<p class="admonition-title">Code:&ensp;python3</p>
<p>experiment.reset_log('my_metric')</p>
</div>
<h2 id="note">Note</h2>
<p>Check Neptune web application to see that reset charts have no data.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset_log(self, log_name):
    &#34;&#34;&#34;Resets the log.

    Removes all data from the log and enables it to be reused from scratch.

    Args:
        log_name (:obj:`str`): The name of log to reset.

    Raises:
        `ChannelDoesNotExist`: When the log with name ``log_name`` does not exist on the server.

    Example:
        Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`.

        .. code:: python3

            experiment.reset_log(&#39;my_metric&#39;)

    Note:
        Check Neptune web application to see that reset charts have no data.
    &#34;&#34;&#34;
    channel = self._find_channel(log_name, ChannelNamespace.USER)
    if channel is None:
        raise ChannelDoesNotExist(self.id, log_name)
    self._backend.reset_channel(channel.id)</code></pre>
</details>
</dd>
<dt id="neptune.experiments.Experiment.send_artifact"><code class="name flex">
<span>def <span class="ident">send_artifact</span></span>(<span>self, artifact, destination=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Save an artifact (file) in experiment storage.</p>
<p>Alias for :meth:<code>~neptune.experiments.Experiment.log_artifact</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_artifact(self, artifact, destination=None):
    &#34;&#34;&#34;Save an artifact (file) in experiment storage.

    Alias for :meth:`~neptune.experiments.Experiment.log_artifact`
    &#34;&#34;&#34;
    return self.log_artifact(artifact, destination)</code></pre>
</details>
</dd>
<dt id="neptune.experiments.Experiment.send_image"><code class="name flex">
<span>def <span class="ident">send_image</span></span>(<span>self, channel_name, x, y=None, name=None, description=None, timestamp=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Log image data in Neptune.</p>
<p>Alias for :meth:<code>~neptune.experiments.Experiment.log_image</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_image(self, channel_name, x, y=None, name=None, description=None, timestamp=None):
    &#34;&#34;&#34;Log image data in Neptune.

    Alias for :meth:`~neptune.experiments.Experiment.log_image`
    &#34;&#34;&#34;
    return self.log_image(channel_name, x, y, name, description, timestamp)</code></pre>
</details>
</dd>
<dt id="neptune.experiments.Experiment.send_metric"><code class="name flex">
<span>def <span class="ident">send_metric</span></span>(<span>self, channel_name, x, y=None, timestamp=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Log metrics (numeric values) in Neptune.</p>
<p>Alias for :meth:<code>~neptune.experiments.Experiment.log_metric</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_metric(self, channel_name, x, y=None, timestamp=None):
    &#34;&#34;&#34;Log metrics (numeric values) in Neptune.

    Alias for :meth:`~neptune.experiments.Experiment.log_metric`
    &#34;&#34;&#34;
    return self.log_metric(channel_name, x, y, timestamp)</code></pre>
</details>
</dd>
<dt id="neptune.experiments.Experiment.send_text"><code class="name flex">
<span>def <span class="ident">send_text</span></span>(<span>self, channel_name, x, y=None, timestamp=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Log text data in Neptune.</p>
<p>Alias for :meth:<code>~neptune.experiments.Experiment.log_text</code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_text(self, channel_name, x, y=None, timestamp=None):
    &#34;&#34;&#34;Log text data in Neptune.

    Alias for :meth:`~neptune.experiments.Experiment.log_text`
    &#34;&#34;&#34;
    return self.log_text(channel_name, x, y, timestamp)</code></pre>
</details>
</dd>
<dt id="neptune.experiments.Experiment.set_property"><code class="name flex">
<span>def <span class="ident">set_property</span></span>(<span>self, key, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Set <code>key-value</code> pair as an experiment property.</p>
<p>If property with given <code>key</code> does not exist, it adds a new one.</p>
<h2 id="args">Args</h2>
<p>key (:obj:<code>str</code>): Property key.
value (:obj:<code>obj</code>): New value of a property.</p>
<h2 id="examples">Examples</h2>
<p>Assuming that <code>experiment</code> is an instance of :class:<code>~neptune.experiments.Experiment</code>:</p>
<div class="admonition code">
<p class="admonition-title">Code:&ensp;python3</p>
<p>experiment.set_property('model', 'LightGBM')
experiment.set_property('magic-number', 7)</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_property(self, key, value):
    &#34;&#34;&#34;Set `key-value` pair as an experiment property.

    If property with given ``key`` does not exist, it adds a new one.

    Args:
        key (:obj:`str`): Property key.
        value (:obj:`obj`): New value of a property.

    Examples:
        Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`:

        .. code:: python3

            experiment.set_property(&#39;model&#39;, &#39;LightGBM&#39;)
            experiment.set_property(&#39;magic-number&#39;, 7)
    &#34;&#34;&#34;
    properties = {p.key: p.value for p in self._backend.get_experiment(self.internal_id).properties}
    properties[key] = str(value)
    return self._backend.update_experiment(
        experiment=self,
        properties=properties
    )</code></pre>
</details>
</dd>
<dt id="neptune.experiments.Experiment.stop"><code class="name flex">
<span>def <span class="ident">stop</span></span>(<span>self, exc_tb=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Marks experiment as finished (succeeded or failed).</p>
<h2 id="args">Args</h2>
<p>exc_tb (:obj:<code>str</code>, optional, default is <code>None</code>): Additional traceback information
to be stored in experiment details in case of failure (stacktrace, etc).
If this argument is <code>None</code> the experiment will be marked as succeeded.
Otherwise, experiment will be marked as failed.</p>
<h2 id="examples">Examples</h2>
<p>Assuming that <code>experiment</code> is an instance of :class:<code>~neptune.experiments.Experiment</code>:</p>
<div class="admonition code">
<p class="admonition-title">Code:&ensp;python3</p>
<h1 id="marks-experiment-as-succeeded">Marks experiment as succeeded</h1>
<p>experiment.stop()</p>
<h1 id="assuming-ex-is-some-exception">Assuming 'ex' is some exception,</h1>
<h1 id="it-marks-experiment-as-failed-with-exception-info-in-experiment-details">it marks experiment as failed with exception info in experiment details.</h1>
<p>experiment.stop(str(ex))</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stop(self, exc_tb=None):
    &#34;&#34;&#34;Marks experiment as finished (succeeded or failed).

    Args:
        exc_tb (:obj:`str`, optional, default is ``None``): Additional traceback information
            to be stored in experiment details in case of failure (stacktrace, etc).
            If this argument is ``None`` the experiment will be marked as succeeded.
            Otherwise, experiment will be marked as failed.

    Examples:
        Assuming that `experiment` is an instance of :class:`~neptune.experiments.Experiment`:

        .. code:: python3

            # Marks experiment as succeeded
            experiment.stop()

            # Assuming &#39;ex&#39; is some exception,
            # it marks experiment as failed with exception info in experiment details.
            experiment.stop(str(ex))
    &#34;&#34;&#34;

    self._channels_values_sender.join()

    try:
        if exc_tb is None:
            self._backend.mark_succeeded(self)
        else:
            self._backend.mark_failed(self, exc_tb)
    except ExperimentAlreadyFinished:
        pass

    self._execution_context.stop()

    # pylint: disable=protected-access
    self._project._remove_stopped_experiment(self)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="neptune" href="index.html">neptune</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="neptune.experiments.Experiment" href="#neptune.experiments.Experiment">Experiment</a></code></h4>
<ul class="">
<li><code><a title="neptune.experiments.Experiment.IMAGE_SIZE_LIMIT_MB" href="#neptune.experiments.Experiment.IMAGE_SIZE_LIMIT_MB">IMAGE_SIZE_LIMIT_MB</a></code></li>
<li><code><a title="neptune.experiments.Experiment.append_tag" href="#neptune.experiments.Experiment.append_tag">append_tag</a></code></li>
<li><code><a title="neptune.experiments.Experiment.append_tags" href="#neptune.experiments.Experiment.append_tags">append_tags</a></code></li>
<li><code><a title="neptune.experiments.Experiment.delete_artifacts" href="#neptune.experiments.Experiment.delete_artifacts">delete_artifacts</a></code></li>
<li><code><a title="neptune.experiments.Experiment.download_artifact" href="#neptune.experiments.Experiment.download_artifact">download_artifact</a></code></li>
<li><code><a title="neptune.experiments.Experiment.download_artifacts" href="#neptune.experiments.Experiment.download_artifacts">download_artifacts</a></code></li>
<li><code><a title="neptune.experiments.Experiment.download_sources" href="#neptune.experiments.Experiment.download_sources">download_sources</a></code></li>
<li><code><a title="neptune.experiments.Experiment.get_channels" href="#neptune.experiments.Experiment.get_channels">get_channels</a></code></li>
<li><code><a title="neptune.experiments.Experiment.get_hardware_utilization" href="#neptune.experiments.Experiment.get_hardware_utilization">get_hardware_utilization</a></code></li>
<li><code><a title="neptune.experiments.Experiment.get_logs" href="#neptune.experiments.Experiment.get_logs">get_logs</a></code></li>
<li><code><a title="neptune.experiments.Experiment.get_numeric_channels_values" href="#neptune.experiments.Experiment.get_numeric_channels_values">get_numeric_channels_values</a></code></li>
<li><code><a title="neptune.experiments.Experiment.get_parameters" href="#neptune.experiments.Experiment.get_parameters">get_parameters</a></code></li>
<li><code><a title="neptune.experiments.Experiment.get_properties" href="#neptune.experiments.Experiment.get_properties">get_properties</a></code></li>
<li><code><a title="neptune.experiments.Experiment.get_system_properties" href="#neptune.experiments.Experiment.get_system_properties">get_system_properties</a></code></li>
<li><code><a title="neptune.experiments.Experiment.get_tags" href="#neptune.experiments.Experiment.get_tags">get_tags</a></code></li>
<li><code><a title="neptune.experiments.Experiment.id" href="#neptune.experiments.Experiment.id">id</a></code></li>
<li><code><a title="neptune.experiments.Experiment.internal_id" href="#neptune.experiments.Experiment.internal_id">internal_id</a></code></li>
<li><code><a title="neptune.experiments.Experiment.limits" href="#neptune.experiments.Experiment.limits">limits</a></code></li>
<li><code><a title="neptune.experiments.Experiment.log_artifact" href="#neptune.experiments.Experiment.log_artifact">log_artifact</a></code></li>
<li><code><a title="neptune.experiments.Experiment.log_image" href="#neptune.experiments.Experiment.log_image">log_image</a></code></li>
<li><code><a title="neptune.experiments.Experiment.log_metric" href="#neptune.experiments.Experiment.log_metric">log_metric</a></code></li>
<li><code><a title="neptune.experiments.Experiment.log_text" href="#neptune.experiments.Experiment.log_text">log_text</a></code></li>
<li><code><a title="neptune.experiments.Experiment.name" href="#neptune.experiments.Experiment.name">name</a></code></li>
<li><code><a title="neptune.experiments.Experiment.remove_property" href="#neptune.experiments.Experiment.remove_property">remove_property</a></code></li>
<li><code><a title="neptune.experiments.Experiment.remove_tag" href="#neptune.experiments.Experiment.remove_tag">remove_tag</a></code></li>
<li><code><a title="neptune.experiments.Experiment.reset_log" href="#neptune.experiments.Experiment.reset_log">reset_log</a></code></li>
<li><code><a title="neptune.experiments.Experiment.send_artifact" href="#neptune.experiments.Experiment.send_artifact">send_artifact</a></code></li>
<li><code><a title="neptune.experiments.Experiment.send_image" href="#neptune.experiments.Experiment.send_image">send_image</a></code></li>
<li><code><a title="neptune.experiments.Experiment.send_metric" href="#neptune.experiments.Experiment.send_metric">send_metric</a></code></li>
<li><code><a title="neptune.experiments.Experiment.send_text" href="#neptune.experiments.Experiment.send_text">send_text</a></code></li>
<li><code><a title="neptune.experiments.Experiment.set_property" href="#neptune.experiments.Experiment.set_property">set_property</a></code></li>
<li><code><a title="neptune.experiments.Experiment.state" href="#neptune.experiments.Experiment.state">state</a></code></li>
<li><code><a title="neptune.experiments.Experiment.stop" href="#neptune.experiments.Experiment.stop">stop</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>